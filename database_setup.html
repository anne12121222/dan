-- =================================================================================================
-- 0. INITIAL CLEANUP
-- Drops all existing objects to ensure a clean slate for recreation.
-- =================================================================================================

-- Drop existing policies and disable RLS
DO $$
DECLARE
    table_record RECORD;
    policy_record RECORD;
BEGIN
    FOR table_record IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(table_record.tablename) || ' DISABLE ROW LEVEL SECURITY;';
        -- Drop all policies for the table
        FOR policy_record IN (SELECT policyname FROM pg_policies WHERE schemaname = 'public' AND tablename = table_record.tablename) LOOP
            EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_record.policyname) || ' ON public.' || quote_ident(table_record.tablename) || ';';
        END LOOP;
    END LOOP;
END $$;

-- Drop trigger on auth.users table
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop tables with CASCADE to remove dependent objects
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop functions
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.get_user_role(uuid);
DROP FUNCTION IF EXISTS public.handle_new_player(text, text, text, text);
DROP FUNCTION IF EXISTS public.create_user_by_master_agent(text, text, text, public.user_role, uuid);
DROP FUNCTION IF EXISTS public.start_next_fight();
DROP FUNCTION IF EXISTS public.close_betting(bigint);
DROP FUNCTION IF EXISTS public.declare_winner(bigint, public.fight_winner);
DROP FUNCTION IF EXISTS public.place_bet(uuid, bigint, numeric, public.bet_choice);
DROP FUNCTION IF EXISTS public.create_coin_request(uuid, numeric);
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, text);
DROP FUNCTION IF EXISTS public.send_message(uuid, text, numeric);
DROP FUNCTION IF EXISTS public.get_player_fight_history(uuid);
DROP FUNCTION IF EXISTS public.get_user_transactions(uuid);
DROP FUNCTION IF EXISTS public.get_agent_requests_for_master(uuid);
DROP FUNCTION IF EXISTS public.get_messages(uuid, uuid);

-- Drop types with CASCADE
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;


-- =================================================================================================
-- 1. TYPE DEFINITIONS
-- Defines custom data types (enums) used throughout the schema.
-- =================================================================================================

CREATE TYPE public.user_role AS ENUM ('PLAYER', 'AGENT', 'MASTER_AGENT', 'OPERATOR');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('MINT', 'TRANSFER', 'COMMISSION', 'BET', 'WINNING', 'REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- =================================================================================================
-- 2. TABLE CREATION
-- Defines the structure of all database tables.
-- =================================================================================================

-- Profiles table to store user-specific data, extending the auth.users table.
CREATE TABLE public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    role public.user_role NOT NULL,
    coin_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id),
    commission_rate numeric(4, 3) NOT NULL DEFAULT 0.070,
    transfer_fee numeric(4, 3) NOT NULL DEFAULT 0.010
);

-- Fights table stores the state of each fight event.
CREATE TABLE public.fights (
    id bigserial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'SETTLED',
    winner public.fight_winner,
    commission numeric(15, 2),
    betting_ends_at timestamptz,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Upcoming Fights queue.
CREATE TABLE public.upcoming_fights (
    id bigserial PRIMARY KEY,
    red_participant text NOT NULL,
    white_participant text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Bets table to record all player wagers.
CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id bigint NOT NULL REFERENCES public.fights(id),
    amount numeric(15, 2) NOT NULL CHECK (amount > 0),
    choice public.bet_choice NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE(user_id, fight_id) -- A user can only bet once per fight.
);

-- Transactions table for a complete ledger of all coin movements.
CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    type public.transaction_type NOT NULL,
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    transaction_timestamp timestamptz NOT NULL DEFAULT now()
);

-- Coin requests between users.
CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL CHECK (amount > 0),
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Messages for the chat system.
CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- =================================================================================================
-- 3. DATABASE FUNCTIONS (RPC)
-- Core business logic encapsulated in server-side functions.
-- =================================================================================================

-- Trigger function to create a profile when a new user signs up in auth.users.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, role, agent_id, coin_balance)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'name', new.email), -- Use name from metadata, fallback to email
    new.email,
    COALESCE((new.raw_user_meta_data->>'role')::public.user_role, 'PLAYER'), -- Use role from metadata, fallback to PLAYER
    (new.raw_user_meta_data->>'agent_id')::uuid,
    100 -- Starting balance for new players
  );
  RETURN new;
END;
$$;

-- Function for Master Agents to create any other user type.
CREATE OR REPLACE FUNCTION public.create_user_by_master_agent(
    name text,
    email text,
    password text,
    role public.user_role,
    master_agent_id uuid
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    new_user_id uuid;
BEGIN
    -- Check if the calling user is a Master Agent
    IF (SELECT p.role FROM public.profiles p WHERE p.id = auth.uid()) != 'MASTER_AGENT' THEN
        RAISE EXCEPTION 'Permission denied: Only Master Agents can create users.';
    END IF;

    -- Create the user in the authentication system
    new_user_id := (auth.admin_create_user(jsonb_build_object(
        'email', email,
        'password', password,
        'email_confirm', true,
        'user_metadata', jsonb_build_object(
            'name', name,
            'role', role,
            'master_agent_id', master_agent_id
        )
    )))->>'id';

    -- The handle_new_user trigger will create the profile.
    -- We just need to set the master_agent_id for Agents.
    IF role = 'AGENT' THEN
        UPDATE public.profiles SET master_agent_id = create_user_by_master_agent.master_agent_id WHERE id = new_user_id;
    END IF;

    RETURN new_user_id;
END;
$$;


-- Function for player self-registration.
CREATE OR REPLACE FUNCTION public.handle_new_player(
    name text,
    email text,
    password text,
    agent_id text
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    new_user_id uuid;
BEGIN
    new_user_id := (auth.admin_create_user(jsonb_build_object(
        'email', email,
        'password', password,
        'email_confirm', true,
        'user_metadata', jsonb_build_object(
            'name', name,
            'role', 'PLAYER',
            'agent_id', agent_id
        )
    )))->>'id';
    RETURN new_user_id;
END;
$$;


-- Operator function to start the next fight from the queue.
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    next_fight record;
    new_fight_id bigint;
BEGIN
    -- Find the next fight in the queue
    SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No upcoming fights in the queue.';
    END IF;

    -- Create a new fight record
    INSERT INTO public.fights (status, betting_ends_at)
    VALUES ('BETTING_OPEN', now() + interval '60 seconds')
    RETURNING id INTO new_fight_id;

    -- Remove the fight from the queue
    DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
END;
$$;

-- Operator function to close betting for a fight.
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE public.fights
    SET status = 'BETTING_CLOSED'
    WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$;

-- Operator function to declare the winner and distribute winnings.
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id bigint, p_winner public.fight_winner)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    total_pool numeric;
    winner_pool numeric;
    loser_pool numeric;
    total_commission numeric;
    player_share numeric;
    payout_amount numeric;
    winning_bet record;
    losing_bet record;
    fight_commission_rate numeric := 0.05; -- 5% commission
BEGIN
    -- Set fight status to SETTLED
    UPDATE public.fights SET winner = p_winner, status = 'SETTLED' WHERE id = p_fight_id;

    -- Calculate pools
    SELECT COALESCE(SUM(amount), 0) INTO total_pool FROM public.bets WHERE fight_id = p_fight_id;
    
    -- If DRAW or CANCELLED, refund all bets
    IF p_winner IN ('DRAW', 'CANCELLED') THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('REFUND', winning_bet.user_id, winning_bet.amount);
        END LOOP;
        RETURN;
    END IF;

    -- Calculate pools for WIN/LOSS scenario
    SELECT COALESCE(SUM(amount), 0) INTO winner_pool FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::bet_choice;
    SELECT COALESCE(SUM(amount), 0) INTO loser_pool FROM public.bets WHERE fight_id = p_fight_id AND choice != p_winner::bet_choice;
    
    total_commission := loser_pool * fight_commission_rate;
    UPDATE public.fights SET commission = total_commission WHERE id = p_fight_id;

    -- Pay out to winners
    IF winner_pool > 0 THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::bet_choice LOOP
            player_share := winning_bet.amount / winner_pool;
            payout_amount := winning_bet.amount + (player_share * (loser_pool - total_commission));
            UPDATE public.profiles SET coin_balance = coin_balance + payout_amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('WINNING', winning_bet.user_id, payout_amount);
        END LOOP;
    END IF;
    
    -- Handle commission distribution
    FOR losing_bet IN SELECT b.*, p.agent_id, p.master_agent_id FROM public.bets b JOIN public.profiles p ON b.user_id = p.id WHERE b.fight_id = p_fight_id AND b.choice != p_winner::bet_choice LOOP
        DECLARE
            agent_comm numeric;
            master_comm numeric;
        BEGIN
            IF losing_bet.agent_id IS NOT NULL THEN
                agent_comm := losing_bet.amount * 0.03; -- 3% to agent
                UPDATE public.profiles SET commission_balance = commission_balance + agent_comm WHERE id = losing_bet.agent_id;
                INSERT INTO public.transactions(type, from_user_id, to_user_id, amount) VALUES('COMMISSION', losing_bet.user_id, losing_bet.agent_id, agent_comm);

                IF losing_bet.master_agent_id IS NOT NULL THEN
                    master_comm := losing_bet.amount * 0.02; -- 2% to master agent
                    UPDATE public.profiles SET commission_balance = commission_balance + master_comm WHERE id = losing_bet.master_agent_id;
                    INSERT INTO public.transactions(type, from_user_id, to_user_id, amount) VALUES('COMMISSION', losing_bet.user_id, losing_bet.master_agent_id, master_comm);
                END IF;
            END IF;
        END;
    END LOOP;
END;
$$;


-- Function to respond to a coin request.
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    req record;
    sender_profile record;
    receiver_profile record;
BEGIN
    SELECT * INTO req FROM public.coin_requests WHERE id = p_request_id AND status = 'PENDING';
    IF NOT FOUND THEN RAISE EXCEPTION 'Request not found or already handled.'; END IF;

    -- Ensure the user responding is the intended recipient
    IF req.to_user_id != auth.uid() THEN RAISE EXCEPTION 'Permission denied.'; END IF;

    UPDATE public.coin_requests SET status = p_response::public.request_status WHERE id = p_request_id;

    IF p_response = 'APPROVED' THEN
        SELECT * INTO sender_profile FROM public.profiles WHERE id = req.from_user_id;
        SELECT * INTO receiver_profile FROM public.profiles WHERE id = req.to_user_id;

        IF receiver_profile.coin_balance < req.amount THEN RAISE EXCEPTION 'Insufficient funds.'; END IF;
        
        -- Perform the transfer
        UPDATE public.profiles SET coin_balance = coin_balance - req.amount WHERE id = req.to_user_id;
        UPDATE public.profiles SET coin_balance = coin_balance + req.amount WHERE id = req.from_user_id;
        INSERT INTO public.transactions (type, from_user_id, to_user_id, amount) VALUES ('TRANSFER', req.to_user_id, req.from_user_id, req.amount);

        -- Adoption logic
        IF sender_profile.role = 'PLAYER' AND sender_profile.agent_id IS NULL AND receiver_profile.role = 'AGENT' THEN
            UPDATE public.profiles SET agent_id = req.to_user_id, master_agent_id = receiver_profile.master_agent_id WHERE id = req.from_user_id;
        ELSIF sender_profile.role = 'AGENT' AND sender_profile.master_agent_id IS NULL AND receiver_profile.role = 'MASTER_AGENT' THEN
            UPDATE public.profiles SET master_agent_id = req.to_user_id WHERE id = req.from_user_id;
        END IF;
    END IF;
END;
$$;

-- Function to send a message and optionally coins.
CREATE OR REPLACE FUNCTION public.send_message(p_receiver_id uuid, p_text text, p_coin_amount numeric)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    sender_id uuid := auth.uid();
BEGIN
    INSERT INTO public.messages (sender_id, receiver_id, text) VALUES (sender_id, p_receiver_id, p_text);
    IF p_coin_amount > 0 THEN
        UPDATE public.profiles SET coin_balance = coin_balance - p_coin_amount WHERE id = sender_id;
        UPDATE public.profiles SET coin_balance = coin_balance + p_coin_amount WHERE id = p_receiver_id;
        INSERT INTO public.transactions (type, from_user_id, to_user_id, amount) VALUES ('TRANSFER', sender_id, p_receiver_id, p_coin_amount);
    END IF;
END;
$$;


-- =================================================================================================
-- 4. DATA-FETCHING FUNCTIONS (RPC)
-- Read-only functions for securely fetching data for the UI.
-- =================================================================================================

CREATE OR REPLACE FUNCTION public.get_player_fight_history(p_user_id uuid)
RETURNS TABLE(id bigint, winner public.fight_winner, commission numeric, bet json, outcome text)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        f.id,
        f.winner,
        f.commission,
        (SELECT row_to_json(b) FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) as bet,
        CASE
            WHEN (SELECT b.choice::text FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = f.winner::text THEN 'WIN'
            WHEN f.winner IN ('DRAW', 'CANCELLED') AND (SELECT 1 FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'REFUND'
            WHEN (SELECT 1 FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'LOSS'
            ELSE NULL
        END as outcome
    FROM fights f
    WHERE f.status = 'SETTLED'
    ORDER BY f.id DESC;
$$;

CREATE OR REPLACE FUNCTION public.get_user_transactions(p_user_id uuid)
RETURNS SETOF public.transactions
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT * FROM public.transactions
    WHERE from_user_id = p_user_id OR to_user_id = p_user_id
    ORDER BY transaction_timestamp DESC;
$$;

CREATE OR REPLACE FUNCTION public.get_agent_requests_for_master(p_master_agent_id uuid)
RETURNS SETOF public.coin_requests
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT r.* FROM public.coin_requests r
    JOIN public.profiles p ON r.from_user_id = p.id
    WHERE r.to_user_id = p_master_agent_id AND r.status = 'PENDING' AND p.role = 'AGENT';
$$;

CREATE OR REPLACE FUNCTION public.get_messages(user1_id uuid, user2_id uuid)
RETURNS SETOF public.messages
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT * FROM public.messages
    WHERE (sender_id = user1_id AND receiver_id = user2_id)
       OR (sender_id = user2_id AND receiver_id = user1_id)
    ORDER BY created_at ASC;
$$;

-- =================================================================================================
-- 5. TRIGGERS & ROW-LEVEL SECURITY (RLS)
-- Secures the database by defining access rules for each role.
-- =================================================================================================

-- Create the trigger that executes handle_new_user on new user creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Enable RLS for all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- RLS POLICIES

-- Profiles Table
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Authenticated users can view all profiles (for lookups)." ON public.profiles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Fights Table
CREATE POLICY "All authenticated users can view fights." ON public.fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Operators can create and update fights." ON public.fights FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Upcoming Fights Table
CREATE POLICY "All authenticated users can view upcoming fights." ON public.upcoming_fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Operators can manage the upcoming fights queue." ON public.upcoming_fights FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Bets Table
CREATE POLICY "Users can view their own bets." ON public.bets FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can view all bets on a fight (anonymized in UI)." ON public.bets FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Players can place bets." ON public.bets FOR INSERT WITH CHECK (auth.uid() = user_id AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'PLAYER');

-- Transactions Table
CREATE POLICY "Users can view their own transactions." ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

-- Coin Requests Table
CREATE POLICY "Users can see requests they sent or received." ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can create coin requests." ON public.coin_requests FOR INSERT WITH CHECK (auth.uid() = from_user_id);
CREATE POLICY "Users can update requests sent to them." ON public.coin_requests FOR UPDATE USING (auth.uid() = to_user_id);

-- Messages Table
CREATE POLICY "Users can see messages they sent or received." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- =================================================================================================
-- 6. REAL-TIME CONFIGURATION
-- Enables real-time updates for the application.
-- =================================================================================================

-- Set REPLICA IDENTITY to FULL for tables that will have real-time updates with RLS
ALTER TABLE public.profiles REPLICA IDENTITY FULL;
ALTER TABLE public.fights REPLICA IDENTITY FULL;
ALTER TABLE public.upcoming_fights REPLICA IDENTITY FULL;
ALTER TABLE public.bets REPLICA IDENTITY FULL;
ALTER TABLE public.transactions REPLICA IDENTITY FULL;
ALTER TABLE public.coin_requests REPLICA IDENTITY FULL;
ALTER TABLE public.messages REPLICA IDENTITY FULL;

-- Add tables to the publication for real-time updates
DROP PUBLICATION IF EXISTS supabase_realtime;
CREATE PUBLICATION supabase_realtime;
ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
ALTER PUBLICATION supabase_realtime ADD TABLE public.fights;
ALTER PUBLICATION supabase_realtime ADD TABLE public.upcoming_fights;
ALTER PUBLICATION supabase_realtime ADD TABLE public.bets;
ALTER PUBLICATION supabase_realtime ADD TABLE public.transactions;
ALTER PUBLICATION supabase_realtime ADD TABLE public.coin_requests;
ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;

-- =================================================================================================
-- END OF SCRIPT
-- =================================================================================================
