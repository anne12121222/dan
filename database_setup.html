-- Reality Boxing Federation Database Setup
-- This script is idempotent and can be run multiple times safely.

-- 1. EXTENSIONS
create extension if not exists "uuid-ossp";

-- 2. SCHEMAS
-- 'public' and 'auth' schemas are used by default.

-- 3. ENUMS (Custom Data Types)
-- Drop existing types if they exist to avoid conflicts, then recreate.
drop type if exists public.user_role cascade;
create type public.user_role as enum ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');

drop type if exists public.fight_status cascade;
create type public.fight_status as enum ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');

drop type if exists public.fight_winner cascade;
create type public.fight_winner as enum ('RED', 'WHITE', 'DRAW', 'CANCELLED');

drop type if exists public.bet_choice cascade;
create type public.bet_choice as enum ('RED', 'WHITE');

drop type if exists public.request_status cascade;
create type public.request_status as enum ('PENDING', 'APPROVED', 'DECLINED');

drop type if exists public.transaction_type cascade;
create type public.transaction_type as enum ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');

-- 4. TABLES
-- Profiles Table: Stores user-specific data, extending the auth.users table.
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  name text not null,
  email text not null unique,
  role public.user_role not null default 'PLAYER',
  coin_balance numeric(15, 2) not null default 0.00,
  commission_balance numeric(15, 2) not null default 0.00,
  commission_rate numeric(3, 2) not null default 0.07, -- 7%
  transfer_fee numeric(3, 2) not null default 0.01, -- 1%
  agent_id uuid references public.profiles(id),
  master_agent_id uuid references public.profiles(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
-- Add comments for clarity
comment on table public.profiles is 'Stores user profile data, linked to authentication.';
comment on column public.profiles.agent_id is 'The superior agent for a player.';
comment on column public.profiles.master_agent_id is 'The superior master agent for an agent.';

-- Other Tables (Fights, Bets, etc.)
create table if not exists public.fights (
  id serial primary key,
  status public.fight_status not null default 'SETTLED',
  winner public.fight_winner,
  commission numeric(15, 2) not null default 0.00,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.upcoming_fights (
  id serial primary key,
  participants jsonb not null
);

create table if not exists public.bets (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id),
  fight_id integer not null references public.fights(id),
  amount numeric(15, 2) not null,
  choice public.bet_choice not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.transactions (
  id uuid primary key default uuid_generate_v4(),
  from_user_id uuid references public.profiles(id),
  to_user_id uuid references public.profiles(id),
  amount numeric(15, 2) not null,
  type public.transaction_type not null,
  transaction_timestamp timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.coin_requests (
  id uuid primary key default uuid_generate_v4(),
  from_user_id uuid not null references public.profiles(id),
  to_user_id uuid not null references public.profiles(id),
  amount numeric(15, 2) not null,
  status public.request_status not null default 'PENDING',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.messages (
  id uuid primary key default uuid_generate_v4(),
  sender_id uuid not null references public.profiles(id),
  receiver_id uuid not null references public.profiles(id),
  text text not null,
  amount numeric(15, 2),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);


-- 5. NEW USER TRIGGER (Replaces RPC call for robust profile creation)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, name, email, role)
  values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.email,
    'PLAYER'::public.user_role -- All new signups default to Player
  );
  return new;
end;
$$ language plpgsql security definer;

-- Drop trigger if it exists to ensure a clean setup
drop trigger if exists on_auth_user_created on auth.users;
-- Create the trigger to automatically create a profile when a new user signs up
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- 6. ROW-LEVEL SECURITY (RLS)

-- Enable RLS on all tables
alter table public.profiles enable row level security;
alter table public.fights enable row level security;
alter table public.upcoming_fights enable row level security;
alter table public.bets enable row level security;
alter table public.transactions enable row level security;
alter table public.coin_requests enable row level security;
alter table public.messages enable row level security;

-- Drop existing policies to ensure a clean slate
drop policy if exists "Enable all access for service_role" on public.profiles;
drop policy if exists "Allow users to read their own profile" on public.profiles;
drop policy if exists "Allow users to update their own profile" on public.profiles;
drop policy if exists "Allow public read access to all fights" on public.fights;
drop policy if exists "Allow public read access to upcoming fights" on public.upcoming_fights;
drop policy if exists "Allow authenticated users to place bets" on public.bets;
drop policy if exists "Allow users to read their own bets" on public.bets;
drop policy if exists "Agents can read their players bets" on public.bets;
drop policy if exists "Master Agents can read their agents players bets" on public.bets;
drop policy if exists "Operators can read all bets" on public.bets;
drop policy if exists "Allow users to read their own transactions" on public.transactions;
drop policy if exists "Allow users to read coin requests involving them" on public.coin_requests;
drop policy if exists "Allow users to create their own coin requests" on public.coin_requests;
drop policy if exists "Allow recipient to update coin request status" on public.coin_requests;
drop policy if exists "Allow users to read messages involving them" on public.messages;
drop policy if exists "Allow users to send messages" on public.messages;

-- Grant basic usage permissions
grant usage on schema public to anon, authenticated, service_role;

-- HELPER FUNCTION
create or replace function public.get_user_role(p_user_id uuid)
returns public.user_role as $$
declare
  v_role public.user_role;
begin
  select role into v_role from public.profiles where id = p_user_id;
  return v_role;
end;
$$ language plpgsql stable security definer set search_path = '';

-- PROFILES POLICIES
create policy "Enable all access for service_role" on public.profiles for all to service_role using (true);
create policy "Allow users to read their own profile" on public.profiles for select to authenticated using (auth.uid() = id);
create policy "Allow users to update their own profile" on public.profiles for update to authenticated using (auth.uid() = id);

-- FIGHTS & UPCOMING FIGHTS POLICIES
create policy "Allow public read access to all fights" on public.fights for select using (true);
create policy "Allow public read access to upcoming fights" on public.upcoming_fights for select using (true);

-- BETS POLICIES
create policy "Allow authenticated users to place bets" on public.bets for insert to authenticated with check (auth.uid() = user_id);
create policy "Allow users to read their own bets" on public.bets for select using (auth.uid() = user_id);
create policy "Agents can read their players bets" on public.bets for select using (
  (select public.get_user_role(auth.uid())) = 'AGENT'::public.user_role and
  (select agent_id from public.profiles where id = bets.user_id) = auth.uid()
);
create policy "Master Agents can read their agents players bets" on public.bets for select using (
  (select public.get_user_role(auth.uid())) = 'MASTER_AGENT'::public.user_role and
  (select master_agent_id from public.profiles where id = (select agent_id from public.profiles where id = bets.user_id)) = auth.uid()
);
create policy "Operators can read all bets" on public.bets for select using (
  (select public.get_user_role(auth.uid())) = 'OPERATOR'::public.user_role
);

-- TRANSACTIONS POLICIES
create policy "Allow users to read their own transactions" on public.transactions for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);

-- COIN REQUESTS POLICIES
create policy "Allow users to read coin requests involving them" on public.coin_requests for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);
create policy "Allow users to create their own coin requests" on public.coin_requests for insert with check (auth.uid() = from_user_id);
create policy "Allow recipient to update coin request status" on public.coin_requests for update using (auth.uid() = to_user_id);

-- MESSAGES POLICIES
create policy "Allow users to read messages involving them" on public.messages for select using (auth.uid() = sender_id or auth.uid() = receiver_id);
create policy "Allow users to send messages" on public.messages for insert with check (auth.uid() = sender_id);


-- 7. DATABASE FUNCTIONS

-- Internal helper functions (SECURITY DEFINER context)
create or replace function internal_transfer_coins(
    p_from_user_id uuid,
    p_to_user_id uuid,
    p_amount numeric,
    p_type transaction_type
) returns void as $$
begin
    update public.profiles set coin_balance = coin_balance - p_amount where id = p_from_user_id;
    update public.profiles set coin_balance = coin_balance + p_amount where id = p_to_user_id;
    insert into public.transactions (from_user_id, to_user_id, amount, type)
    values (p_from_user_id, p_to_user_id, p_amount, p_type);
end;
$$ language plpgsql security definer set search_path = '';

create or replace function internal_set_player_agent(
    p_player_id uuid,
    p_agent_id uuid
) returns void as $$
begin
    update public.profiles set agent_id = p_agent_id where id = p_player_id and role = 'PLAYER'::public.user_role;
end;
$$ language plpgsql security definer set search_path = '';


-- Function to create a coin request
create or replace function public.create_coin_request(
    p_amount numeric,
    p_target_user_id uuid default null
) returns text as $$
declare
    v_caller_profile public.profiles;
    v_target_profile public.profiles;
    v_final_target_id uuid;
begin
    select * into v_caller_profile from public.profiles where id = auth.uid();
    
    if v_caller_profile.role = 'PLAYER'::public.user_role then
        if v_caller_profile.agent_id is not null then
            v_final_target_id := v_caller_profile.agent_id;
        else
            if p_target_user_id is null then return 'Error: You must select an Agent to request coins from.'; end if;
            select * into v_target_profile from public.profiles where id = p_target_user_id;
            if v_target_profile is null or v_target_profile.role <> 'AGENT'::public.user_role then return 'Error: Invalid Agent selected.'; end if;
            v_final_target_id := p_target_user_id;
        end if;
    elsif v_caller_profile.role = 'AGENT'::public.user_role then
        if v_caller_profile.master_agent_id is not null then
             v_final_target_id := v_caller_profile.master_agent_id;
        else
             if p_target_user_id is null then return 'Error: You must select a Master Agent to request coins from.'; end if;
            select * into v_target_profile from public.profiles where id = p_target_user_id;
            if v_target_profile is null or v_target_profile.role <> 'MASTER_AGENT'::public.user_role then return 'Error: Invalid Master Agent selected.'; end if;
            v_final_target_id := p_target_user_id;
        end if;
    else
        return 'Error: Only Players and Agents can request coins.';
    end if;
    
    insert into public.coin_requests (from_user_id, to_user_id, amount) values (auth.uid(), v_final_target_id, p_amount);
    return null;
end;
$$ language plpgsql volatile;

-- Function to respond to a coin request (DEADLOCK-PROOF)
create or replace function public.respond_to_coin_request(
    p_request_id uuid,
    p_response request_status
) returns text as $$
declare
    v_request public.coin_requests;
    v_requester public.profiles;
    v_responder public.profiles;
begin
    -- Lock the request row first to perform initial validation.
    select * into v_request from public.coin_requests where id = p_request_id for update;

    if v_request is null then return 'Error: Request not found.'; end if;
    if v_request.to_user_id <> auth.uid() then return 'Error: You are not authorized to respond to this request.'; end if;
    if v_request.status <> 'PENDING'::public.request_status then return 'Error: This request has already been actioned.'; end if;

    -- Now, lock the user profiles in a deterministic order (by UUID) to prevent deadlocks.
    if v_request.from_user_id < v_request.to_user_id then
        select * into v_requester from public.profiles where id = v_request.from_user_id for update;
        select * into v_responder from public.profiles where id = v_request.to_user_id for update;
    else
        select * into v_responder from public.profiles where id = v_request.to_user_id for update;
        select * into v_requester from public.profiles where id = v_request.from_user_id for update;
    end if;

    if p_response = 'APPROVED'::public.request_status then
        if v_responder.coin_balance < v_request.amount then return 'Error: Insufficient funds to approve this request.'; end if;

        perform internal_transfer_coins(v_responder.id, v_requester.id, v_request.amount, 'TRANSFER'::public.transaction_type);

        -- Adoption Logic: If an Agent approves a request from an unassigned player
        if v_responder.role = 'AGENT'::public.user_role and v_requester.role = 'PLAYER'::public.user_role and v_requester.agent_id is null then
            perform internal_set_player_agent(v_requester.id, v_responder.id);
        end if;
    end if;

    update public.coin_requests set status = p_response where id = p_request_id;
    return null;
end;
$$ language plpgsql volatile;

-- Function for data fetching
drop function if exists public.get_user_view_data();
create or replace function public.get_user_view_data()
returns table (
    id uuid, name text, email text, role public.user_role, coin_balance numeric,
    commission_balance numeric, commission_rate numeric, transfer_fee numeric,
    agent_id uuid, master_agent_id uuid
) as $$
declare
    v_caller_profile public.profiles;
begin
    select * into v_caller_profile from public.profiles where public.profiles.id = auth.uid();
    
    if v_caller_profile.role = 'OPERATOR'::public.user_role then
        return query select p.* from public.profiles p;
    elsif v_caller_profile.role = 'MASTER_AGENT'::public.user_role then
        return query select p.* from public.profiles p where p.master_agent_id = v_caller_profile.id or p.id = v_caller_profile.id;
    elsif v_caller_profile.role = 'AGENT'::public.user_role then
        -- Agent sees their players, themself, their master agent, and other master agents if they are unassigned
        return query 
            select p.* from public.profiles p 
            where p.agent_id = v_caller_profile.id -- their players
            or p.id = v_caller_profile.id -- themself
            or p.id = v_caller_profile.master_agent_id -- their master agent
            or (v_caller_profile.master_agent_id is null and p.role = 'MASTER_AGENT'::public.user_role); -- all master agents if unassigned
    elsif v_caller_profile.role = 'PLAYER'::public.user_role then
        if v_caller_profile.agent_id is null then
            -- Unassigned player can see all agents to make a request, plus themself
            return query select p.* from public.profiles p where p.role = 'AGENT'::public.user_role or p.id = v_caller_profile.id;
        else
            -- Assigned player sees themself and their agent
            return query select p.* from public.profiles p where p.id = v_caller_profile.agent_id or p.id = v_caller_profile.id;
        end if;
    end if;
end;
$$ language plpgsql security definer stable set search_path = '';

-- DATA FETCHING FUNCTIONS (Full Implementations)
drop function if exists public.get_all_users_for_operator();
create or replace function public.get_all_users_for_operator()
returns table (
    id uuid, name text, email text, role public.user_role, coin_balance numeric,
    commission_balance numeric, commission_rate numeric, transfer_fee numeric,
    agent_id uuid, master_agent_id uuid
) as $$
begin
    return query select p.* from public.profiles p;
end;
$$ language plpgsql stable security definer set search_path = '';

drop function if exists public.get_coin_requests_for_user();
create or replace function public.get_coin_requests_for_user()
returns table(
    id uuid, from_user_id uuid, to_user_id uuid, amount numeric,
    status public.request_status, created_at timestamp with time zone
) as $$
begin
    return query
    select cr.id, cr.from_user_id, cr.to_user_id, cr.amount, cr.status, cr.created_at
    from public.coin_requests cr
    where cr.from_user_id = auth.uid() or cr.to_user_id = auth.uid();
end;
$$ language plpgsql stable security invoker;

drop function if exists public.get_transactions_for_user();
create or replace function public.get_transactions_for_user()
returns table(
    id uuid, from_user_id uuid, to_user_id uuid, amount numeric,
    type public.transaction_type, transaction_timestamp timestamp with time zone
) as $$
begin
    return query
    select t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.transaction_timestamp
    from public.transactions t
    where t.from_user_id = auth.uid() or t.to_user_id = auth.uid();
end;
$$ language plpgsql stable security invoker;

drop function if exists public.get_messages(uuid);
create or replace function public.get_messages(p_other_user_id uuid)
returns table(
    id uuid, sender_id uuid, receiver_id uuid, text text,
    amount numeric, created_at timestamp with time zone
) as $$
begin
    return query
    select m.id, m.sender_id, m.receiver_id, m.text, m.amount, m.created_at
    from public.messages m
    where (m.sender_id = auth.uid() and m.receiver_id = p_other_user_id)
       or (m.sender_id = p_other_user_id and m.receiver_id = auth.uid())
    order by m.created_at asc;
end;
$$ language plpgsql stable security invoker;

-- FULLY IMPLEMENTED FUNCTIONS (Replacing stubs)

create or replace function public.send_message_and_coins(
    p_receiver_id uuid, 
    p_text text, 
    p_amount numeric
) 
returns text as $$
declare
    v_sender_profile public.profiles;
    v_receiver_profile public.profiles;
    v_sender_id uuid := auth.uid();
begin
    if p_amount > 0 then
        -- Lock profiles in a deterministic order to prevent deadlocks
        if v_sender_id < p_receiver_id then
            select * into v_sender_profile from public.profiles where id = v_sender_id for update;
            select * into v_receiver_profile from public.profiles where id = p_receiver_id for update;
        else
            select * into v_receiver_profile from public.profiles where id = p_receiver_id for update;
            select * into v_sender_profile from public.profiles where id = v_sender_id for update;
        end if;
        
        if v_sender_profile is null then return 'Error: Sender profile not found.'; end if;
        if v_receiver_profile is null then return 'Error: Receiver profile not found.'; end if;

        if v_sender_profile.coin_balance < p_amount then
            return 'Error: Insufficient funds.';
        end if;
        
        -- Perform transfer using the secure helper function
        perform internal_transfer_coins(v_sender_id, p_receiver_id, p_amount, 'TRANSFER'::public.transaction_type);
    end if;

    -- Insert message, ensuring text is not empty
    if p_text is not null and p_text <> '' then
        insert into public.messages (sender_id, receiver_id, text, amount)
        values (v_sender_id, p_receiver_id, p_text, p_amount);
    end if;

    return null;
end;
$$ language plpgsql volatile;


create or replace function public.place_bet(
    p_fight_id int,
    p_amount numeric,
    p_choice bet_choice
) 
returns text as $$
declare
    v_fight public.fights;
    v_player public.profiles;
begin
    -- Lock the player's profile first to prevent race conditions on their balance
    select * into v_player from public.profiles where id = auth.uid() for update;
    
    if v_player.coin_balance < p_amount then
        return 'Error: Insufficient balance.';
    end if;

    select * into v_fight from public.fights where id = p_fight_id;

    if v_fight is null then
        return 'Error: Fight not found.';
    end if;
    
    if v_fight.status <> 'BETTING_OPEN'::public.fight_status then
        return 'Error: Betting is closed for this fight.';
    end if;

    if exists (select 1 from public.bets where user_id = auth.uid() and fight_id = p_fight_id) then
        return 'Error: You have already placed a bet on this fight.';
    end if;

    -- Decrease balance
    update public.profiles set coin_balance = coin_balance - p_amount where id = auth.uid();
    
    -- Record transaction
    insert into public.transactions (from_user_id, to_user_id, amount, type)
    values (auth.uid(), null, p_amount, 'BET_PLACE'::public.transaction_type);

    -- Insert bet
    insert into public.bets (user_id, fight_id, amount, choice)
    values (auth.uid(), p_fight_id, p_amount, p_choice);

    return null;
end;
$$ language plpgsql volatile;


-- Stubs for operator functions (can be implemented later)
create or replace function public.start_next_fight() returns void as $$ begin end; $$ language plpgsql;
create or replace function public.close_betting(p_fight_id int) returns void as $$ begin end; $$ language plpgsql;
create or replace function public.declare_winner(p_fight_id int, p_winner_text text) returns void as $$ begin end; $$ language plpgsql;
create or replace function public.add_upcoming_fight(p_red text, p_white text) returns void as $$ begin end; $$ language plpgsql;


-- END OF SCRIPT