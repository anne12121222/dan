-- Grand Overhaul: This version is hardened, fully functional, and non-recursive.

-- 1. CLEANUP: Drop old objects with specific function signatures to avoid ambiguity
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(integer) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(integer, public.fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.add_upcoming_fight(text, text) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(integer, numeric, public.bet_choice) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(numeric) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, public.request_status) CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric) CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.create_agent(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.create_master_agent(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.create_operator(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.get_registerable_agents() CASCADE;
DROP FUNCTION IF EXISTS public.get_all_users_for_operator() CASCADE;
-- Drop the new helper functions if they exist from a previous run
DROP FUNCTION IF EXISTS public.get_my_agent_id() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_master_agent_id() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_role() CASCADE;


-- 2. TYPES: Define custom data types
CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');

-- 3. TABLES: Define the data structure
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name text NOT NULL,
  email text NOT NULL,
  role public.user_role NOT NULL,
  coin_balance numeric NOT NULL DEFAULT 0,
  commission_balance numeric NOT NULL DEFAULT 0,
  commission_rate numeric NOT NULL DEFAULT 0.07, -- 7% default
  transfer_fee numeric NOT NULL DEFAULT 0.01, -- 1% default
  agent_id uuid REFERENCES public.profiles(id),
  master_agent_id uuid REFERENCES public.profiles(id),
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.fights (
  id serial PRIMARY KEY,
  status public.fight_status NOT NULL,
  winner public.fight_winner,
  commission numeric NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.upcoming_fights (
  id serial PRIMARY KEY,
  participants jsonb NOT NULL -- { "red": "Team A", "white": "Team B" }
);

CREATE TABLE public.bets (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  fight_id integer NOT NULL REFERENCES public.fights(id),
  amount numeric NOT NULL,
  choice public.bet_choice NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.transactions (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  from_user_id uuid REFERENCES public.profiles(id),
  to_user_id uuid REFERENCES public.profiles(id),
  amount numeric NOT NULL,
  type public.transaction_type NOT NULL,
  transaction_timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.coin_requests (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  from_user_id uuid NOT NULL REFERENCES public.profiles(id),
  to_user_id uuid NOT NULL REFERENCES public.profiles(id),
  amount numeric NOT NULL,
  status public.request_status NOT NULL DEFAULT 'PENDING',
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.messages (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id uuid NOT NULL REFERENCES public.profiles(id),
  receiver_id uuid NOT NULL REFERENCES public.profiles(id),
  text text NOT NULL,
  amount numeric,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- 4. RLS HELPER FUNCTIONS (NON-RECURSIVE)
-- These functions safely get the current user's data to avoid recursion in RLS policies.
CREATE FUNCTION public.get_my_agent_id()
RETURNS uuid AS $$
BEGIN
  RETURN (SELECT agent_id FROM public.profiles WHERE id = auth.uid());
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE FUNCTION public.get_my_master_agent_id()
RETURNS uuid AS $$
BEGIN
  RETURN (SELECT master_agent_id FROM public.profiles WHERE id = auth.uid());
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


-- 5. RLS (ROW LEVEL SECURITY): Secure data access
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Allow public access to read fights and upcoming fights
CREATE POLICY "Allow public read access to fights" ON public.fights FOR SELECT USING (true);
CREATE POLICY "Allow public read access to upcoming fights" ON public.upcoming_fights FOR SELECT USING (true);

-- DEFINITIVE FIX: A new, non-recursive policy for profiles.
-- This single policy handles all roles correctly and avoids infinite recursion.
CREATE POLICY "Allow hierarchical and self read access" ON public.profiles FOR SELECT
USING (
  -- 1. A user can see their own profile
  id = auth.uid() OR
  -- 2. A user can see their direct subordinates (e.g., Master Agent sees their Agents)
  master_agent_id = auth.uid() OR
  agent_id = auth.uid() OR
  -- 3. A user can see their direct superiors (e.g., an Agent sees their Master Agent)
  id = public.get_my_agent_id() OR
  id = public.get_my_master_agent_id()
);


-- Bets policies
CREATE POLICY "Allow players to see their own bets" ON public.bets FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Allow agents/masters to see their players'/agents' bets" ON public.bets FOR SELECT
USING (
    user_id IN (SELECT id FROM public.profiles WHERE agent_id = auth.uid() OR master_agent_id = auth.uid())
);
CREATE POLICY "Allow operators to see all bets" ON public.bets FOR SELECT
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Other policies for authenticated users
CREATE POLICY "Allow users to see their own data" ON public.transactions FOR SELECT USING (from_user_id = auth.uid() OR to_user_id = auth.uid());
CREATE POLICY "Allow users to see their own data" ON public.coin_requests FOR SELECT USING (from_user_id = auth.uid() OR to_user_id = auth.uid());
CREATE POLICY "Allow users to see their own messages" ON public.messages FOR SELECT USING (sender_id = auth.uid() OR receiver_id = auth.uid());

-- NOTE: The dangerous recursive operator policy on profiles has been removed.
-- The app correctly uses an RPC call (`get_all_users_for_operator`) for this functionality.
CREATE POLICY "Allow operator to manage upcoming fights" ON public.upcoming_fights FOR ALL
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR')
WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');


-- 6. TRIGGERS: Automate profile creation
-- This version is robust and handles user creation from the Supabase dashboard.
CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, role, agent_id, master_agent_id)
  VALUES (
    NEW.id,
    -- Provide a default for name if not in metadata
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email, 'New User'),
    NEW.email,
    -- Default role to PLAYER if not specified
    COALESCE((NEW.raw_user_meta_data->>'role')::public.user_role, 'PLAYER'),
    (NEW.raw_user_meta_data->>'agent_id')::uuid,
    (NEW.raw_user_meta_data->>'master_agent_id')::uuid
  );

  -- Give new players a starting balance
  IF COALESCE((NEW.raw_user_meta_data->>'role')::public.user_role, 'PLAYER') = 'PLAYER' THEN
    UPDATE public.profiles SET coin_balance = 1000 WHERE id = NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 7. RPC FUNCTIONS: Define business logic
-- Operator Functions
CREATE FUNCTION public.start_next_fight()
RETURNS void AS $$
DECLARE
  next_fight public.upcoming_fights;
BEGIN
  -- Check if user is an operator
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can start fights.';
  END IF;
  
  -- Get the next fight from the queue
  SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
  
  IF next_fight IS NULL THEN
    RAISE EXCEPTION 'No upcoming fights in the queue.';
  END IF;
  
  -- Create a new fight
  INSERT INTO public.fights (status) VALUES ('BETTING_OPEN');
  
  -- Remove it from the queue
  DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.close_betting(p_fight_id integer)
RETURNS void AS $$
BEGIN
  -- Check if user is an operator
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can close betting.';
  END IF;
  
  UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.declare_winner(p_fight_id integer, p_winner public.fight_winner)
RETURNS void AS $$
DECLARE
  total_pool numeric;
  winning_pool numeric;
  payout_ratio numeric;
  winning_bet record;
  player_profit numeric;
  agent_commission numeric;
  master_commission numeric;
  total_commission numeric := 0;
  agent_profile public.profiles;
  master_agent_profile public.profiles;
  operator_id uuid;
BEGIN
  -- Check if user is an operator
  operator_id := auth.uid();
  IF (SELECT role FROM public.profiles WHERE id = operator_id) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can declare winners.';
  END IF;
  
  -- Update fight status
  UPDATE public.fights SET winner = p_winner, status = 'SETTLED' WHERE id = p_fight_id;
  
  -- If DRAW or CANCELLED, refund all bets
  IF p_winner = 'DRAW' OR p_winner = 'CANCELLED' THEN
    FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
      UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
      INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, winning_bet.user_id, winning_bet.amount, 'BET_REFUND');
    END LOOP;
    RETURN;
  END IF;

  -- Calculate payout ratio for winning bets
  SELECT SUM(amount) INTO total_pool FROM public.bets WHERE fight_id = p_fight_id;
  SELECT SUM(amount) INTO winning_pool FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::text::public.bet_choice;
  
  IF winning_pool IS NULL OR winning_pool = 0 THEN
    RETURN; -- No winning bets, nothing to pay out
  END IF;
  
  payout_ratio := total_pool / winning_pool;

  -- Payout winners and calculate commissions
  FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::text::public.bet_choice LOOP
    -- Payout the winner
    player_profit := (winning_bet.amount * payout_ratio) - winning_bet.amount;
    UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount + player_profit WHERE id = winning_bet.user_id;
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, winning_bet.user_id, winning_bet.amount + player_profit, 'BET_WIN');
    
    -- Calculate and distribute commission
    SELECT * INTO agent_profile FROM public.profiles WHERE id = (SELECT agent_id FROM public.profiles WHERE id = winning_bet.user_id);
    IF agent_profile IS NOT NULL THEN
      agent_commission := player_profit * agent_profile.commission_rate;
      UPDATE public.profiles SET commission_balance = commission_balance + agent_commission WHERE id = agent_profile.id;
      INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (winning_bet.user_id, agent_profile.id, agent_commission, 'COMMISSION');
      total_commission := total_commission + agent_commission;
      
      SELECT * INTO master_agent_profile FROM public.profiles WHERE id = agent_profile.master_agent_id;
      IF master_agent_profile IS NOT NULL THEN
        master_commission := player_profit * master_agent_profile.commission_rate;
        UPDATE public.profiles SET commission_balance = commission_balance + master_commission WHERE id = master_agent_profile.id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (winning_bet.user_id, master_agent_profile.id, master_commission, 'COMMISSION');
        total_commission := total_commission + master_commission;
      END IF;
    END IF;
  END LOOP;
  
  -- Update operator balance and fight commission record
  UPDATE public.profiles SET coin_balance = coin_balance - total_commission WHERE id = operator_id;
  UPDATE public.fights SET commission = total_commission WHERE id = p_fight_id;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.add_upcoming_fight(p_red text, p_white text)
RETURNS void AS $$
BEGIN
  -- Check if user is an operator
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can add fights.';
  END IF;
  INSERT INTO public.upcoming_fights (participants) VALUES (jsonb_build_object('red', p_red, 'white', p_white));
END;
$$ LANGUAGE plpgsql;


-- Player Functions
CREATE FUNCTION public.place_bet(p_fight_id integer, p_amount numeric, p_choice public.bet_choice)
RETURNS text AS $$
DECLARE
  current_balance numeric;
BEGIN
  -- Check if user is a player
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'PLAYER' THEN
    RETURN 'Error: Only players can place bets.';
  END IF;
  
  -- Check if betting is open
  IF (SELECT status FROM public.fights WHERE id = p_fight_id) != 'BETTING_OPEN' THEN
    RETURN 'Error: Betting is currently closed for this fight.';
  END IF;
  
  -- Check if player has sufficient balance
  SELECT coin_balance INTO current_balance FROM public.profiles WHERE id = auth.uid();
  IF current_balance < p_amount THEN
    RETURN 'Error: Insufficient coin balance.';
  END IF;
  
  -- Deduct amount and insert bet
  UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
  INSERT INTO public.bets (user_id, fight_id, amount, choice) VALUES (auth.uid(), p_fight_id, p_amount, p_choice);
  INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), NULL, p_amount, 'BET_PLACE');
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Coin Request Functions
CREATE FUNCTION public.create_coin_request(p_amount numeric)
RETURNS text AS $$
DECLARE
  current_user_profile public.profiles;
  target_user_id uuid;
BEGIN
  SELECT * INTO current_user_profile FROM public.profiles WHERE id = auth.uid();
  
  -- Determine who the request should go to
  IF current_user_profile.role = 'PLAYER' THEN
    target_user_id := current_user_profile.agent_id;
  ELSIF current_user_profile.role = 'AGENT' THEN
    target_user_id := current_user_profile.master_agent_id;
  ELSE
    RETURN 'Error: Only Players and Agents can request coins.';
  END IF;
  
  IF target_user_id IS NULL THEN
    RETURN 'Error: You do not have a superior to request coins from.';
  END IF;
  
  INSERT INTO public.coin_requests (from_user_id, to_user_id, amount) VALUES (auth.uid(), target_user_id, p_amount);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
DECLARE
  request public.coin_requests;
  responder_balance numeric;
BEGIN
  SELECT * INTO request FROM public.coin_requests WHERE id = p_request_id AND to_user_id = auth.uid();
  
  IF request IS NULL THEN
    RETURN 'Error: Request not found or you are not authorized to respond.';
  END IF;
  
  IF request.status != 'PENDING' THEN
    RETURN 'Error: This request has already been handled.';
  END IF;

  IF p_response = 'APPROVED' THEN
    SELECT coin_balance INTO responder_balance FROM public.profiles WHERE id = auth.uid();
    IF responder_balance < request.amount THEN
        RETURN 'Error: Insufficient balance to approve this request.';
    END IF;

    UPDATE public.profiles SET coin_balance = coin_balance - request.amount WHERE id = auth.uid();
    UPDATE public.profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), request.from_user_id, request.amount, 'TRANSFER');
  END IF;
  
  UPDATE public.coin_requests SET status = p_response WHERE id = p_request_id;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Messaging Functions
CREATE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, amount numeric, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT m.id, m.sender_id, m.receiver_id, m.text, m.amount, m.created_at
  FROM public.messages m
  WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_other_user_id)
     OR (m.sender_id = p_other_user_id AND m.receiver_id = auth.uid())
  ORDER BY m.created_at ASC;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS text AS $$
DECLARE
  sender_profile public.profiles;
  fee_amount numeric;
  fee_recipient_id uuid;
BEGIN
  SELECT * INTO sender_profile FROM public.profiles WHERE id = auth.uid();
  
  IF p_amount IS NOT NULL AND p_amount > 0 THEN
    IF sender_profile.coin_balance < p_amount THEN
        RETURN 'Error: Insufficient balance to send coins.';
    END IF;

    fee_amount := p_amount * sender_profile.transfer_fee;
    
    -- Determine who gets the commission
    IF sender_profile.role = 'AGENT' THEN
        fee_recipient_id := sender_profile.master_agent_id;
    ELSIF sender_profile.role = 'MASTER_AGENT' THEN
        -- Master Agents sending to Agents don't have fees in this logic, but could be added.
        fee_recipient_id := NULL; 
    ELSE
        -- No fees for other roles
        fee_recipient_id := NULL;
    END IF;
    
    -- Perform transfers
    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
    UPDATE public.profiles SET coin_balance = coin_balance + (p_amount - fee_amount) WHERE id = p_receiver_id;
    
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), p_receiver_id, p_amount, 'TRANSFER');

    IF fee_amount > 0 AND fee_recipient_id IS NOT NULL THEN
        UPDATE public.profiles SET commission_balance = commission_balance + fee_amount WHERE id = fee_recipient_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), fee_recipient_id, fee_amount, 'COMMISSION');
    END IF;
  END IF;
  
  INSERT INTO public.messages (sender_id, receiver_id, text, amount) VALUES (auth.uid(), p_receiver_id, p_text, p_amount);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Data Fetching Functions
CREATE FUNCTION public.get_transactions_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, type public.transaction_type, transaction_timestamp timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.transaction_timestamp
  FROM public.transactions t
  WHERE t.from_user_id = auth.uid() OR t.to_user_id = auth.uid()
  ORDER BY t.transaction_timestamp DESC;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.get_coin_requests_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, status public.request_status, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT r.id, r.from_user_id, r.to_user_id, r.amount, r.status, r.created_at
  FROM public.coin_requests r
  WHERE r.from_user_id = auth.uid() OR r.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

-- A new secure function for operators to fetch all user data.
-- This prevents the recursive RLS issue for other user roles.
CREATE FUNCTION public.get_all_users_for_operator()
RETURNS TABLE(id uuid, name text, email text, role public.user_role, coin_balance numeric, commission_balance numeric, commission_rate numeric, transfer_fee numeric, agent_id uuid, master_agent_id uuid) AS $$
BEGIN
  IF (SELECT p.role FROM public.profiles p WHERE p.id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can call this function.';
  END IF;
  
  RETURN QUERY SELECT p.id, p.name, p.email, p.role, p.coin_balance, p.commission_balance, p.commission_rate, p.transfer_fee, p.agent_id, p.master_agent_id FROM public.profiles p;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER FUNCTION public.get_all_users_for_operator() SET search_path = public;


-- User Creation Functions
CREATE FUNCTION public.create_agent(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
  new_user_id uuid;
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'MASTER_AGENT' THEN
    RETURN 'Error: Only Master Agents can create Agents.';
  END IF;

  -- Create the user in auth.users
  SELECT id FROM auth.admin_create_user(
    p_email, 
    p_password, 
    jsonb_build_object('name', p_name, 'role', 'AGENT', 'master_agent_id', auth.uid())
  ) INTO new_user_id;
  
  RETURN 'Agent ' || p_name || ' created successfully.';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER FUNCTION public.create_agent(text, text, text) SET search_path = public;

CREATE FUNCTION public.create_master_agent(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
  new_user_id uuid;
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RETURN 'Error: Only Operators can create Master Agents.';
  END IF;

  SELECT id FROM auth.admin_create_user(
    p_email, 
    p_password, 
    jsonb_build_object('name', p_name, 'role', 'MASTER_AGENT')
  ) INTO new_user_id;

  RETURN 'Master Agent ' || p_name || ' created successfully.';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER FUNCTION public.create_master_agent(text, text, text) SET search_path = public;

CREATE FUNCTION public.create_operator(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
  new_user_id uuid;
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'MASTER_AGENT' THEN
    RETURN 'Error: Only Master Agents can create Operators.';
  END IF;

  SELECT id FROM auth.admin_create_user(
    p_email, 
    p_password, 
    jsonb_build_object('name', p_name, 'role', 'OPERATOR')
  ) INTO new_user_id;

  RETURN 'Operator ' || p_name || ' created successfully.';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER FUNCTION public.create_operator(text, text, text) SET search_path = public;


-- Function for registration form
CREATE OR REPLACE FUNCTION public.get_registerable_agents()
RETURNS TABLE(id uuid, name text) AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.name FROM public.profiles p WHERE p.role = 'AGENT';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
ALTER FUNCTION public.get_registerable_agents() SET search_path = public;
-- Grant execute permission to the anon role so they can see agents on signup
GRANT EXECUTE ON FUNCTION public.get_registerable_agents() TO anon;