-- Grand Overhaul: This version is hardened, fully functional, and non-recursive.

-- 1. CLEANUP: Drop old objects with specific function signatures to avoid ambiguity
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
-- FIX: Drop all possible signatures for functions being updated to ensure a clean slate.
DROP FUNCTION IF EXISTS public.close_betting(integer) CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(bigint) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(integer, public.fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(bigint, public.fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(bigint, text) CASCADE;
DROP FUNCTION IF EXISTS public.add_upcoming_fight(text, text) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(integer, integer, public.bet_choice) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(bigint, integer, public.bet_choice) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(numeric) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(integer) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(integer, uuid) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, public.request_status) CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, integer) CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_registerable_agents() CASCADE;
DROP FUNCTION IF EXISTS public.get_all_users_for_operator() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_agent_id() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_master_agent_id() CASCADE;
DROP FUNCTION IF EXISTS public.get_user_view_data() CASCADE;


-- 2. TYPES: Define custom data types
CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');

-- 3. TABLES: Define the data structure
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name text NOT NULL,
  email text NOT NULL,
  role public.user_role NOT NULL,
  coin_balance numeric NOT NULL DEFAULT 0,
  commission_balance numeric NOT NULL DEFAULT 0,
  commission_rate numeric NOT NULL DEFAULT 0.07, -- 7% default
  transfer_fee numeric NOT NULL DEFAULT 0.01, -- 1% default
  agent_id uuid REFERENCES public.profiles(id),
  master_agent_id uuid REFERENCES public.profiles(id),
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.fights (
  id serial PRIMARY KEY,
  status public.fight_status NOT NULL,
  winner public.fight_winner,
  commission numeric NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.upcoming_fights (
  id serial PRIMARY KEY,
  participants jsonb NOT NULL -- { "red": "Team A", "white": "Team B" }
);

CREATE TABLE public.bets (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  fight_id integer NOT NULL REFERENCES public.fights(id),
  amount numeric NOT NULL,
  choice public.bet_choice NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.transactions (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  from_user_id uuid REFERENCES public.profiles(id),
  to_user_id uuid REFERENCES public.profiles(id),
  amount numeric NOT NULL,
  type public.transaction_type NOT NULL,
  transaction_timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.coin_requests (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  from_user_id uuid NOT NULL REFERENCES public.profiles(id),
  to_user_id uuid NOT NULL REFERENCES public.profiles(id),
  amount numeric NOT NULL,
  status public.request_status NOT NULL DEFAULT 'PENDING',
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.messages (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id uuid NOT NULL REFERENCES public.profiles(id),
  receiver_id uuid NOT NULL REFERENCES public.profiles(id),
  text text NOT NULL,
  amount numeric,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- 4. RLS (ROW LEVEL SECURITY): Secure data access
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Allow public access to read upcoming fights
CREATE POLICY "Allow public read access to upcoming fights" ON public.upcoming_fights FOR SELECT USING (true);

-- Allow public read access to fights, and operator management
CREATE POLICY "Allow public read access to fights" ON public.fights FOR SELECT USING (true);
CREATE POLICY "Allow operators to manage fights" ON public.fights FOR ALL
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR')
WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');


-- Replace complex, recursive RLS with a simple policy. Data access is now handled by secure RPC functions.
CREATE POLICY "Allow users to see and update their own profile" ON public.profiles
FOR ALL USING (id = auth.uid())
WITH CHECK (id = auth.uid());

-- Bets policies
CREATE POLICY "Allow players to see their own bets" ON public.bets FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Allow agents/masters to see their players'/agents' bets" ON public.bets FOR SELECT
USING (
    user_id IN (SELECT id FROM public.profiles WHERE agent_id = auth.uid() OR master_agent_id = auth.uid())
);
CREATE POLICY "Allow operators to see all bets" ON public.bets FOR SELECT
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Other policies for authenticated users
CREATE POLICY "Allow users to see their own data" ON public.transactions FOR SELECT USING (from_user_id = auth.uid() OR to_user_id = auth.uid());
CREATE POLICY "Allow users to see their own data" ON public.coin_requests FOR SELECT USING (from_user_id = auth.uid() OR to_user_id = auth.uid());
CREATE POLICY "Allow users to see their own messages" ON public.messages FOR SELECT USING (sender_id = auth.uid() OR receiver_id = auth.uid());

CREATE POLICY "Allow operator to manage upcoming fights" ON public.upcoming_fights FOR ALL
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR')
WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');


-- 5. TRIGGERS: Automate profile creation
CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, role, agent_id, master_agent_id)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email, 'New User'),
    NEW.email,
    COALESCE((NEW.raw_user_meta_data->>'role')::public.user_role, 'PLAYER'),
    (NEW.raw_user_meta_data->>'agent_id')::uuid,
    (NEW.raw_user_meta_data->>'master_agent_id')::uuid
  );

  -- Give new players a starting balance
  IF COALESCE((NEW.raw_user_meta_data->>'role')::public.user_role, 'PLAYER') = 'PLAYER' THEN
    UPDATE public.profiles SET coin_balance = 1000 WHERE id = NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 6. RPC FUNCTIONS: Define business logic
-- Operator Functions
CREATE FUNCTION public.start_next_fight()
RETURNS void AS $$
DECLARE
  next_fight public.upcoming_fights;
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can start fights.';
  END IF;
  
  SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
  
  IF next_fight IS NULL THEN
    RAISE EXCEPTION 'No upcoming fights in the queue.';
  END IF;
  
  INSERT INTO public.fights (status) VALUES ('BETTING_OPEN');
  
  DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void AS $$
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can close betting.';
  END IF;
  
  UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql;

-- FIX: Changed p_winner from enum to text to resolve function ambiguity from the frontend.
CREATE FUNCTION public.declare_winner(p_fight_id bigint, p_winner_text text)
RETURNS void AS $$
DECLARE
  p_winner public.fight_winner;
  total_pool numeric;
  winning_pool numeric;
  payout_ratio numeric;
  winning_bet record;
  player_profit numeric;
  agent_commission numeric;
  master_commission numeric;
  total_commission_paid numeric := 0;
  agent_profile public.profiles;
  master_agent_profile public.profiles;
  operator_id uuid;
  house_rake_rate numeric := 0.10; -- 10% house rake
  house_take numeric;
  distributable_pool numeric;
BEGIN
  operator_id := auth.uid();
  p_winner := p_winner_text::public.fight_winner;

  IF (SELECT role FROM public.profiles WHERE id = operator_id) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can declare winners.';
  END IF;

  -- Ensure the fight is in the correct state
  IF (SELECT status FROM public.fights WHERE id = p_fight_id) != 'BETTING_CLOSED' THEN
    RAISE EXCEPTION 'Fight is not ready to be settled.';
  END IF;
  
  UPDATE public.fights SET winner = p_winner, status = 'SETTLED' WHERE id = p_fight_id;
  
  -- Handle DRAW or CANCELLED fights by refunding all bets
  IF p_winner = 'DRAW' OR p_winner = 'CANCELLED' THEN
    FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
      UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
      INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, winning_bet.user_id, winning_bet.amount, 'BET_REFUND');
    END LOOP;
    RETURN;
  END IF;

  -- Calculate pools and house rake for winning scenarios
  SELECT SUM(amount) INTO total_pool FROM public.bets WHERE fight_id = p_fight_id;
  
  -- If no one bet, there's nothing to do
  IF total_pool IS NULL OR total_pool = 0 THEN
    RETURN; 
  END IF;
  
  house_take := total_pool * house_rake_rate;
  distributable_pool := total_pool - house_take;
  
  SELECT SUM(amount) INTO winning_pool FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::text::public.bet_choice;
  
  -- If there were bets but no one chose the winner, the house takes the entire pool
  IF winning_pool IS NULL OR winning_pool = 0 THEN
    UPDATE public.profiles SET coin_balance = coin_balance + total_pool WHERE id = operator_id;
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, operator_id, total_pool, 'COMMISSION'); -- Using 'COMMISSION' for house profit
    UPDATE public.fights SET commission = total_pool WHERE id = p_fight_id;
    RETURN; 
  END IF;
  
  -- Calculate payouts for winners
  payout_ratio := distributable_pool / winning_pool;

  FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner::text::public.bet_choice LOOP
    player_profit := (winning_bet.amount * payout_ratio) - winning_bet.amount;
    
    -- Ensure profit is not negative due to floating point math
    IF player_profit < 0 THEN
      player_profit := 0;
    END IF;

    -- Pay the winner their original bet + profit
    UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount + player_profit WHERE id = winning_bet.user_id;
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, winning_bet.user_id, winning_bet.amount + player_profit, 'BET_WIN');
    
    -- Calculate and distribute commissions based on player's profit
    SELECT * INTO agent_profile FROM public.profiles WHERE id = (SELECT agent_id FROM public.profiles WHERE id = winning_bet.user_id);
    IF agent_profile IS NOT NULL THEN
      agent_commission := player_profit * agent_profile.commission_rate;
      UPDATE public.profiles SET commission_balance = commission_balance + agent_commission WHERE id = agent_profile.id;
      INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (winning_bet.user_id, agent_profile.id, agent_commission, 'COMMISSION');
      total_commission_paid := total_commission_paid + agent_commission;
      
      SELECT * INTO master_agent_profile FROM public.profiles WHERE id = agent_profile.master_agent_id;
      IF master_agent_profile IS NOT NULL THEN
        master_commission := player_profit * master_agent_profile.commission_rate;
        UPDATE public.profiles SET commission_balance = commission_balance + master_commission WHERE id = master_agent_profile.id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (winning_bet.user_id, master_agent_profile.id, master_commission, 'COMMISSION');
        total_commission_paid := total_commission_paid + master_commission;
      END IF;
    END IF;
  END LOOP;
  
  -- The Operator's net profit is the house take minus commissions paid out
  UPDATE public.profiles SET coin_balance = coin_balance + (house_take - total_commission_paid) WHERE id = operator_id;
  -- Store the gross house take in the fight record for auditing
  UPDATE public.fights SET commission = house_take WHERE id = p_fight_id;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.add_upcoming_fight(p_red text, p_white text)
RETURNS void AS $$
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can add fights.';
  END IF;
  INSERT INTO public.upcoming_fights (participants) VALUES (jsonb_build_object('red', p_red, 'white', p_white));
END;
$$ LANGUAGE plpgsql;

-- Player Functions
CREATE FUNCTION public.place_bet(p_fight_id bigint, p_amount integer, p_choice public.bet_choice)
RETURNS text AS $$
DECLARE
  current_balance numeric;
BEGIN
  IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'PLAYER' THEN
    RETURN 'Error: Only players can place bets.';
  END IF;
  
  IF (SELECT status FROM public.fights WHERE id = p_fight_id) != 'BETTING_OPEN' THEN
    RETURN 'Error: Betting is currently closed for this fight.';
  END IF;
  
  SELECT coin_balance INTO current_balance FROM public.profiles WHERE id = auth.uid();
  IF current_balance < p_amount THEN
    RETURN 'Error: Insufficient coin balance.';
  END IF;
  
  UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
  INSERT INTO public.bets (user_id, fight_id, amount, choice) VALUES (auth.uid(), p_fight_id, p_amount, p_choice);
  INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), NULL, p_amount, 'BET_PLACE');
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Coin Request Functions
CREATE FUNCTION public.create_coin_request(p_amount integer, p_target_user_id uuid DEFAULT NULL)
RETURNS text AS $$
DECLARE
  current_user_profile public.profiles;
  target_user_id uuid;
  target_user_role public.user_role;
BEGIN
  SELECT * INTO current_user_profile FROM public.profiles WHERE id = auth.uid();
  
  -- If a target is explicitly provided (Agent requesting from a specific Master Agent)
  IF p_target_user_id IS NOT NULL THEN
    -- Security check: Ensure agents are requesting from Master Agents
    IF current_user_profile.role = 'AGENT' THEN
      SELECT role INTO target_user_role FROM public.profiles WHERE id = p_target_user_id;
      IF target_user_role != 'MASTER_AGENT' THEN
        RETURN 'Error: Agents can only request coins from Master Agents.';
      END IF;
      target_user_id := p_target_user_id;
    ELSE
      RETURN 'Error: Specifying a request target is not allowed for your role.';
    END IF;
  -- If no target is provided, use the hierarchy (Player requesting from their Agent)
  ELSE
    IF current_user_profile.role = 'PLAYER' THEN
      target_user_id := current_user_profile.agent_id;
    ELSE
      -- Agents MUST now specify a target Master Agent.
      RETURN 'Error: You must select a Master Agent to request coins from.';
    END IF;
  END IF;

  IF target_user_id IS NULL THEN
    RETURN 'Error: You do not have a superior to request coins from.';
  END IF;
  
  INSERT INTO public.coin_requests (from_user_id, to_user_id, amount) VALUES (auth.uid(), target_user_id, p_amount);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
DECLARE
  request public.coin_requests;
  responder_balance numeric;
  requesting_user_profile public.profiles;
BEGIN
  SELECT * INTO request FROM public.coin_requests WHERE id = p_request_id AND to_user_id = auth.uid();
  
  IF request IS NULL THEN
    RETURN 'Error: Request not found or you are not authorized to respond.';
  END IF;
  
  IF request.status != 'PENDING' THEN
    RETURN 'Error: This request has already been handled.';
  END IF;

  IF p_response = 'APPROVED' THEN
    SELECT coin_balance INTO responder_balance FROM public.profiles WHERE id = auth.uid();
    IF responder_balance < request.amount THEN
        RETURN 'Error: Insufficient balance to approve this request.';
    END IF;

    -- Transfer coins
    UPDATE public.profiles SET coin_balance = coin_balance - request.amount WHERE id = auth.uid();
    UPDATE public.profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), request.from_user_id, request.amount, 'TRANSFER');

    -- NEW LOGIC: "Adopt" the agent if they don't have a master agent
    SELECT * INTO requesting_user_profile FROM public.profiles WHERE id = request.from_user_id;
    
    -- Only Master Agents can adopt Agents
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'MASTER_AGENT' AND requesting_user_profile.role = 'AGENT' THEN
      -- Only adopt if the agent doesn't already have a master. This prevents poaching.
      IF requesting_user_profile.master_agent_id IS NULL THEN
        UPDATE public.profiles SET master_agent_id = auth.uid() WHERE id = request.from_user_id;
      END IF;
    END IF;

  END IF;
  
  UPDATE public.coin_requests SET status = p_response WHERE id = p_request_id;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Messaging Functions
CREATE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, amount numeric, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT m.id, m.sender_id, m.receiver_id, m.text, m.amount, m.created_at
  FROM public.messages m
  WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_other_user_id)
     OR (m.sender_id = p_other_user_id AND m.receiver_id = auth.uid())
  ORDER BY m.created_at ASC;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount integer)
RETURNS text AS $$
DECLARE
  sender_profile public.profiles;
  fee_amount numeric;
  fee_recipient_id uuid;
BEGIN
  SELECT * INTO sender_profile FROM public.profiles WHERE id = auth.uid();
  
  IF p_amount IS NOT NULL AND p_amount > 0 THEN
    IF sender_profile.coin_balance < p_amount THEN
        RETURN 'Error: Insufficient balance to send coins.';
    END IF;

    fee_amount := p_amount * sender_profile.transfer_fee;
    
    IF sender_profile.role = 'AGENT' THEN
        fee_recipient_id := sender_profile.master_agent_id;
    ELSIF sender_profile.role = 'MASTER_AGENT' THEN
        fee_recipient_id := NULL; 
    ELSE
        fee_recipient_id := NULL;
    END IF;
    
    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
    UPDATE public.profiles SET coin_balance = coin_balance + (p_amount - fee_amount) WHERE id = p_receiver_id;
    
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), p_receiver_id, p_amount, 'TRANSFER');

    IF fee_amount > 0 AND fee_recipient_id IS NOT NULL THEN
        UPDATE public.profiles SET commission_balance = commission_balance + fee_amount WHERE id = fee_recipient_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), fee_recipient_id, fee_amount, 'COMMISSION');
    END IF;
  END IF;
  
  INSERT INTO public.messages (sender_id, receiver_id, text, amount) VALUES (auth.uid(), p_receiver_id, p_text, p_amount);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Data Fetching Functions
CREATE FUNCTION public.get_transactions_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, type public.transaction_type, transaction_timestamp timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.transaction_timestamp
  FROM public.transactions t
  WHERE t.from_user_id = auth.uid() OR t.to_user_id = auth.uid()
  ORDER BY t.transaction_timestamp DESC;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.get_coin_requests_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, status public.request_status, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY
  SELECT r.id, r.from_user_id, r.to_user_id, r.amount, r.status, r.created_at
  FROM public.coin_requests r
  WHERE r.from_user_id = auth.uid() OR r.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION public.get_all_users_for_operator()
RETURNS TABLE(id uuid, name text, email text, role public.user_role, coin_balance numeric, commission_balance numeric, commission_rate numeric, transfer_fee numeric, agent_id uuid, master_agent_id uuid) 
LANGUAGE plpgsql 
SECURITY DEFINER 
SET search_path = public
AS $$
BEGIN
  IF (SELECT p.role FROM public.profiles p WHERE p.id = auth.uid()) != 'OPERATOR' THEN
    RAISE EXCEPTION 'Only operators can call this function.';
  END IF;
  
  RETURN QUERY SELECT p.id, p.name, p.email, p.role, p.coin_balance, p.commission_balance, p.commission_rate, p.transfer_fee, p.agent_id, p.master_agent_id FROM public.profiles p;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_view_data()
RETURNS SETOF public.profiles
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_profile public.profiles;
BEGIN
  -- Get the current user's full profile to check their role and relationships
  SELECT * INTO v_user_profile FROM public.profiles WHERE id = auth.uid();
  
  -- This function returns all profiles a user is allowed to see based on their role and hierarchy
  RETURN QUERY
  SELECT * FROM public.profiles p
  WHERE
    -- 1. The user themselves
    p.id = auth.uid() OR
    -- 2. Their direct agent superior (if they are a player)
    p.id = v_user_profile.agent_id OR
    -- 3. Their direct master agent superior (if they are an agent)
    p.id = v_user_profile.master_agent_id OR
    -- 4. Their direct player subordinates (if they are an agent)
    p.agent_id = auth.uid() OR
    -- 5. Their direct agent subordinates (if they are a master agent)
    p.master_agent_id = auth.uid() OR
    -- 6. SPECIAL CASE: Agents need to see all Master Agents to make a request
    (v_user_profile.role = 'AGENT' AND p.role = 'MASTER_AGENT');
END;
$$;


-- Function for registration form
CREATE OR REPLACE FUNCTION public.get_registerable_agents()
RETURNS TABLE(id uuid, name text) 
LANGUAGE plpgsql 
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.name FROM public.profiles p WHERE p.role = 'AGENT';
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_registerable_agents() TO anon;