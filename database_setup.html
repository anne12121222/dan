-- Reality Boxing Federation - Database Setup Script
-- This script is idempotent and can be run multiple times.

-- SETUP PHASE 1: INITIAL CLEANUP
-- REAL-TIME FIX: Drop functions without parameters to remove all possible overloads, fixing ambiguity errors.
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user;
drop function if exists public.create_agent_user;
drop function if exists public.create_operator_user;
drop function if exists public.create_master_agent_user;
drop function if exists public.get_registerable_agents;
drop function if exists public.get_all_users_for_operator;
drop function if exists public.respond_to_coin_request;
-- FIX: Explicitly drop known overloads of the function to resolve ambiguity.
drop function if exists public.send_message_and_coins(uuid, text, integer);
drop function if exists public.send_message_and_coins(uuid, text, numeric);
-- FIX: Explicitly drop known overloads of the function to resolve ambiguity.
drop function if exists public.place_bet(integer, integer, public.bet_choice_enum);
drop function if exists public.place_bet(integer, numeric, public.bet_choice_enum);
-- FIX: Explicitly drop known overloads of the function to resolve ambiguity.
drop function if exists public.create_coin_request(uuid, integer);
drop function if exists public.create_coin_request(uuid, numeric);
drop function if exists public.start_next_fight;
-- FIX: Explicitly drop known overloads of the function to resolve ambiguity.
drop function if exists public.close_betting();
drop function if exists public.close_betting(integer);
-- FIX: Explicitly drop known overloads of the function to resolve ambiguity.
drop function if exists public.declare_winner(integer, text);
drop function if exists public.declare_winner(integer, public.winner_enum);
-- FIX: Explicitly drop the function with its arguments to resolve ambiguity.
drop function if exists public.add_upcoming_fight(text, text);

-- Drop tables in reverse order of dependency. This also removes RLS policies.
drop table if exists public.bets cascade;
drop table if exists public.transactions cascade;
drop table if exists public.coin_requests cascade;
drop table if exists public.messages cascade;
drop table if exists public.fights cascade;
drop table if exists public.upcoming_fights cascade;
drop table if exists public.profiles cascade;

-- Now drop the function that the RLS policies depended on.
drop function if exists public.get_user_view_data();

-- Drop types
drop type if exists public.user_role cascade;
drop type if exists public.fight_status_enum cascade;
drop type if exists public.winner_enum cascade;
drop type if exists public.bet_choice_enum cascade;
drop type if exists public.transaction_type_enum cascade;
drop type if exists public.request_status_enum cascade;


-- SETUP PHASE 2: TYPES & TABLES
create type public.user_role as enum ('PLAYER', 'AGENT', 'MASTER_AGENT', 'OPERATOR');
create type public.fight_status_enum as enum ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
create type public.winner_enum as enum ('RED', 'WHITE', 'DRAW', 'CANCELLED');
create type public.bet_choice_enum as enum ('RED', 'WHITE');
create type public.transaction_type_enum as enum ('MINT', 'TRANSFER', 'COMMISSION', 'BET', 'WINNING', 'REFUND');
create type public.request_status_enum as enum ('PENDING', 'APPROVED', 'DECLINED');

create table public.profiles (
    id uuid not null primary key references auth.users(id) on delete cascade,
    name text not null,
    email text not null unique,
    role public.user_role not null default 'PLAYER',
    coin_balance numeric not null default 0,
    commission_balance numeric not null default 0,
    commission_rate numeric not null default 0.07, -- 7%
    transfer_fee numeric not null default 0.01, -- 1%
    agent_id uuid references public.profiles(id) on delete set null,
    master_agent_id uuid references public.profiles(id) on delete set null
);
comment on table public.profiles is 'Stores all user-specific data.';

create table public.upcoming_fights (
    id serial primary key,
    participants jsonb not null,
    created_at timestamptz not null default now()
);
comment on table public.upcoming_fights is 'Queue for fights waiting to be started.';

create table public.fights (
    id int primary key,
    winner public.winner_enum,
    participants jsonb,
    status public.fight_status_enum not null default 'BETTING_OPEN',
    created_at timestamptz not null default now(),
    settled_at timestamptz,
    commission numeric not null default 0
);
comment on table public.fights is 'Record of all fights, both active and settled.';

create table public.bets (
    id uuid not null primary key default gen_random_uuid(),
    user_id uuid not null references public.profiles(id) on delete cascade,
    fight_id int not null references public.fights(id) on delete cascade,
    amount numeric not null check (amount > 0),
    choice public.bet_choice_enum not null,
    created_at timestamptz not null default now()
);
comment on table public.bets is 'Log of all bets placed by players.';

create table public.transactions (
    id uuid not null primary key default gen_random_uuid(),
    type public.transaction_type_enum not null,
    from_user_id uuid references public.profiles(id) on delete set null,
    to_user_id uuid references public.profiles(id) on delete set null,
    amount numeric not null,
    transaction_timestamp timestamptz not null default now()
);
comment on table public.transactions is 'Financial ledger for all coin movements.';

create table public.coin_requests (
    id uuid not null primary key default gen_random_uuid(),
    from_user_id uuid not null references public.profiles(id) on delete cascade,
    to_user_id uuid not null references public.profiles(id) on delete cascade,
    amount numeric not null check (amount > 0),
    status public.request_status_enum not null default 'PENDING',
    created_at timestamptz not null default now()
);
comment on table public.coin_requests is 'Tracks requests for coins between users.';

create table public.messages (
    id uuid not null primary key default gen_random_uuid(),
    sender_id uuid not null references public.profiles(id) on delete cascade,
    receiver_id uuid not null references public.profiles(id) on delete cascade,
    text text not null,
    created_at timestamptz not null default now()
);
comment on table public.messages is 'Stores chat messages between users.';

-- SETUP PHASE 2.5: RLS HELPER FUNCTIONS (Moved here to fix dependency error)
create or replace function public.get_user_view_data()
returns table(id uuid)
language plpgsql
security definer
set search_path = public, auth
as $$
declare
    current_user_id uuid := auth.uid();
    current_user_role public.user_role;
    current_user_agent_id uuid;
    current_user_master_agent_id uuid;
begin
    select role, agent_id, master_agent_id into current_user_role, current_user_agent_id, current_user_master_agent_id
    from public.profiles p where p.id = current_user_id;

    -- Return the user themselves first
    return query select p.id from public.profiles p where p.id = current_user_id;

    if current_user_role = 'OPERATOR'::public.user_role then
        return query select p.id from public.profiles p; -- Operators see everyone
    elsif current_user_role = 'MASTER_AGENT'::public.user_role then
        return query select p.id from public.profiles p where p.master_agent_id = current_user_id;
    elsif current_user_role = 'AGENT'::public.user_role then
        return query select p.id from public.profiles p where p.agent_id = current_user_id;
        if current_user_master_agent_id is not null then
           return query select p.id from public.profiles p where p.id = current_user_master_agent_id;
        end if;
    elsif current_user_role = 'PLAYER'::public.user_role then
       if current_user_agent_id is not null then
           return query select p.id from public.profiles p where p.id = current_user_agent_id;
        end if;
    end if;
end;
$$;
comment on function public.get_user_view_data is 'Returns all user IDs a user is allowed to see in their hierarchy.';


-- SETUP PHASE 3: ROW-LEVEL SECURITY (RLS) & REAL-TIME
alter table public.profiles enable row level security;
alter table public.upcoming_fights enable row level security;
alter table public.fights enable row level security;
alter table public.bets enable row level security;
alter table public.transactions enable row level security;
alter table public.coin_requests enable row level security;
alter table public.messages enable row level security;

-- REAL-TIME FIX: Set REPLICA IDENTITY to FULL for tables with RLS that need real-time updates.
-- This allows Supabase to broadcast changes correctly.
alter table public.profiles replica identity full;
alter table public.fights replica identity full;
alter table public.bets replica identity full;
alter table public.coin_requests replica identity full;
alter table public.messages replica identity full;
alter table public.transactions replica identity full;
alter table public.upcoming_fights replica identity full;


-- Profiles Policies
create policy "Users can view their own profile." on public.profiles for select using (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);
create policy "Superiors can view their subordinates." on public.profiles for select using (id in (select get_user_view_data()));
-- Allow unassigned players/agents to see their potential superiors for coin requests
create policy "Unassigned users can see potential superiors" on public.profiles for select using (role = 'AGENT'::public.user_role or role = 'MASTER_AGENT'::public.user_role);


-- Fights / Upcoming Fights Policies (publicly visible)
create policy "All users can view fights." on public.fights for select using (true);
create policy "All users can view upcoming fights." on public.upcoming_fights for select using (true);

-- Bets Policies
create policy "Users can view their own bets." on public.bets for select using (auth.uid() = user_id);
create policy "Superiors can view their subordinates' bets." on public.bets for select using (user_id in (select get_user_view_data()));
create policy "Users can insert their own bets." on public.bets for insert with check (auth.uid() = user_id);

-- Transactions Policies
create policy "Users can view their own transactions." on public.transactions for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);

-- Coin Requests Policies
create policy "Users can see requests they sent or received." on public.coin_requests for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);
create policy "Users can create their own coin requests." on public.coin_requests for insert with check (auth.uid() = from_user_id);
create policy "Recipient can update a coin request." on public.coin_requests for update using (auth.uid() = to_user_id);

-- Messages Policies
create policy "Users can see messages they sent or received." on public.messages for select using (auth.uid() = sender_id or auth.uid() = receiver_id);
create policy "Users can send messages." on public.messages for insert with check (auth.uid() = sender_id);


-- SETUP PHASE 3.5: PUBLICATION
-- DEFINITIVE REAL-TIME FIX: Ensure all tables are part of the real-time publication.
-- This is a robust fix for environments where the default might have been altered.
alter publication supabase_realtime add table public.profiles;
alter publication supabase_realtime add table public.upcoming_fights;
alter publication supabase_realtime add table public.fights;
alter publication supabase_realtime add table public.bets;
alter publication supabase_realtime add table public.transactions;
alter publication supabase_realtime add table public.coin_requests;
alter publication supabase_realtime add table public.messages;


-- SETUP PHASE 4: USER CREATION TRIGGER (FOR PUBLIC SIGN-UP ONLY)
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  -- This trigger is now ONLY for the public sign-up form.
  -- Admin creation functions will insert profiles directly.
  -- The `if not exists` check prevents conflicts.
  if not exists (select 1 from public.profiles where id = new.id) then
    insert into public.profiles (id, name, email, role, agent_id)
    values (
      new.id,
      coalesce(new.raw_user_meta_data->>'name', split_part(new.email, '@', 1)),
      new.email,
      'PLAYER'::public.user_role,
      (new.raw_user_meta_data->>'agent_id')::uuid
    );
  end if;
  return new;
end;
$$;
comment on function public.handle_new_user is 'Trigger function that fires after a new user signs up via the public form.';

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- SETUP PHASE 5: STORED PROCEDURES & FUNCTIONS (RPC)

-- User Management RPCs (DEFINITIVE FIX)
create or replace function public.create_agent_user(p_name text, p_email text, p_password text)
returns text
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  new_user_id uuid;
begin
  if not exists (select 1 from public.profiles where id = auth.uid() and role = 'MASTER_AGENT'::public.user_role) then
    return 'Error: Only Master Agents can create new Agents.';
  end if;

  -- Step 1: Create the user in the authentication system
  select auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' into new_user_id;

  if new_user_id is null then
      return 'Error: Could not create user in authentication system.';
  end if;
  
  -- Step 2: Directly insert the profile. Agent is created UNASSIGNED.
  insert into public.profiles (id, name, email, role, master_agent_id)
  values (new_user_id, p_name, p_email, 'AGENT'::public.user_role, NULL);

  return 'Success: Agent created.';
exception
  when unique_violation then
    perform auth.admin.delete_user(new_user_id); -- Clean up orphaned auth user
    return 'Error: An account with this email already exists.';
  when others then
    if new_user_id is not null then
        perform auth.admin.delete_user(new_user_id); -- Clean up orphaned auth user
    end if;
    return 'Error: A server error occurred. ' || SQLERRM;
end;
$$;
comment on function public.create_agent_user(text, text, text) is 'Allows a Master Agent to create a new, unassigned Agent user.';

create or replace function public.create_master_agent_user(p_name text, p_email text, p_password text)
returns text
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  new_user_id uuid;
begin
  if not exists (select 1 from public.profiles where id = auth.uid() and role = 'MASTER_AGENT'::public.user_role) then
    return 'Error: Only Master Agents can create new Master Agents.';
  end if;

  select auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' into new_user_id;

  if new_user_id is null then
      return 'Error: Could not create user in authentication system.';
  end if;
  
  insert into public.profiles (id, name, email, role)
  values (new_user_id, p_name, p_email, 'MASTER_AGENT'::public.user_role);

  return 'Success: Master Agent created.';
exception
  when unique_violation then
    perform auth.admin.delete_user(new_user_id);
    return 'Error: An account with this email already exists.';
  when others then
    if new_user_id is not null then
        perform auth.admin.delete_user(new_user_id);
    end if;
    return 'Error: A server error occurred. ' || SQLERRM;
end;
$$;
comment on function public.create_master_agent_user(text, text, text) is 'Allows a Master Agent to create a new Master Agent user.';


create or replace function public.create_operator_user(p_name text, p_email text, p_password text)
returns text
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  new_user_id uuid;
begin
  if not exists (select 1 from public.profiles where id = auth.uid() and role = 'MASTER_AGENT'::public.user_role) then
    return 'Error: Only Master Agents can create new Operators.';
  end if;

  select auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' into new_user_id;

  if new_user_id is null then
      return 'Error: Could not create user in authentication system.';
  end if;

  insert into public.profiles (id, name, email, role)
  values (new_user_id, p_name, p_email, 'OPERATOR'::public.user_role);

  return 'Success: Operator created.';
exception
  when unique_violation then
    perform auth.admin.delete_user(new_user_id);
    return 'Error: An account with this email already exists.';
  when others then
    if new_user_id is not null then
        perform auth.admin.delete_user(new_user_id);
    end if;
    return 'Error: A server error occurred. ' || SQLERRM;
end;
$$;
comment on function public.create_operator_user(text, text, text) is 'Allows a Master Agent to create a new Operator user.';


-- Data Fetching RPCs
create or replace function public.get_registerable_agents()
returns setof public.profiles
language sql
stable
as $$
  select * from public.profiles where role = 'AGENT'::public.user_role;
$$;
comment on function public.get_registerable_agents is 'Returns a list of all agents for the registration dropdown.';

create or replace function public.get_all_users_for_operator()
returns setof public.profiles
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if (select role from public.profiles where id = auth.uid()) <> 'OPERATOR'::public.user_role then
    raise exception 'Permission denied.';
  end if;
  return query select * from public.profiles;
end;
$$;
comment on function public.get_all_users_for_operator is 'Returns all users on the platform, for operators only.';

-- Financial & Communication RPCs
create or replace function public.create_coin_request(p_to_user_id uuid, p_amount numeric)
returns void
language plpgsql
as $$
begin
  insert into public.coin_requests (from_user_id, to_user_id, amount)
  values (auth.uid(), p_to_user_id, p_amount);
end;
$$;
comment on function public.create_coin_request(uuid, numeric) is 'Creates a new coin request from the current user to a target user.';

create or replace function public.respond_to_coin_request(p_request_id uuid, p_response public.request_status_enum)
returns text
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  req public.coin_requests;
  sender_profile public.profiles;
  receiver_profile public.profiles;
begin
  -- Lock rows to prevent race conditions
  select * into req from public.coin_requests where id = p_request_id for update;

  if req is null then return 'Error: Request not found.'; end if;
  if req.status <> 'PENDING'::public.request_status_enum then return 'Error: Request already actioned.'; end if;
  if req.to_user_id <> auth.uid() then return 'Error: You are not the recipient of this request.'; end if;

  if p_response = 'APPROVED'::public.request_status_enum then
    -- Lock profiles in a deterministic order to prevent deadlocks
    select * into receiver_profile from public.profiles where id = req.to_user_id for update;
    select * into sender_profile from public.profiles where id = req.from_user_id for update;
    
    if receiver_profile.coin_balance < req.amount then return 'Error: Insufficient balance.'; end if;

    -- Automatic Adoption Logic
    if sender_profile.role = 'PLAYER'::public.user_role and sender_profile.agent_id is null and receiver_profile.role = 'AGENT'::public.user_role then
        -- Player is adopted by Agent
        update public.profiles set agent_id = req.to_user_id where id = req.from_user_id;
    elsif sender_profile.role = 'AGENT'::public.user_role and sender_profile.master_agent_id is null and receiver_profile.role = 'MASTER_AGENT'::public.user_role then
        -- Agent is adopted by Master Agent
        update public.profiles set master_agent_id = req.to_user_id where id = req.from_user_id;
    end if;


    -- Perform transfer
    update public.profiles set coin_balance = coin_balance - req.amount where id = req.to_user_id;
    update public.profiles set coin_balance = coin_balance + req.amount where id = req.from_user_id;
    
    -- Create transaction record
    insert into public.transactions (type, from_user_id, to_user_id, amount)
    values ('TRANSFER'::public.transaction_type_enum, req.to_user_id, req.from_user_id, req.amount);

  end if;

  update public.coin_requests set status = p_response where id = p_request_id;
  return 'Success';
end;
$$;
comment on function public.respond_to_coin_request(uuid, public.request_status_enum) is 'Allows a user to approve or decline a coin request. Approving adopts unassigned users.';

create or replace function public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
returns text
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  sender_profile public.profiles;
  receiver_profile public.profiles;
  transfer_fee numeric;
begin
  if (p_text is null or p_text = '') and (p_amount is null or p_amount <= 0) then
      return 'Error: Cannot send an empty message with no coins.';
  end if;

  -- Lock profiles in deterministic order to prevent deadlocks
  if auth.uid() < p_receiver_id then
    select * into sender_profile from public.profiles where id = auth.uid() for update;
    select * into receiver_profile from public.profiles where id = p_receiver_id for update;
  else
    select * into receiver_profile from public.profiles where id = p_receiver_id for update;
    select * into sender_profile from public.profiles where id = auth.uid() for update;
  end if;

  if p_text is not null and p_text <> '' then
    insert into public.messages (sender_id, receiver_id, text) values (auth.uid(), p_receiver_id, p_text);
  end if;

  if p_amount > 0 then
    transfer_fee := p_amount * sender_profile.transfer_fee;
    if sender_profile.coin_balance < (p_amount + transfer_fee) then
      return 'Error: Insufficient balance for transfer and fee.';
    end if;

    -- Perform transfer
    update public.profiles set coin_balance = coin_balance - (p_amount + transfer_fee) where id = auth.uid();
    update public.profiles set coin_balance = coin_balance + p_amount where id = p_receiver_id;
    
    -- Send fee to sender's superior
    if sender_profile.role = 'PLAYER'::public.user_role and sender_profile.agent_id is not null then
      update public.profiles set commission_balance = commission_balance + transfer_fee where id = sender_profile.agent_id;
    elsif sender_profile.role = 'AGENT'::public.user_role and sender_profile.master_agent_id is not null then
      update public.profiles set commission_balance = commission_balance + transfer_fee where id = sender_profile.master_agent_id;
    end if;

    -- Create transaction logs
    insert into public.transactions (type, from_user_id, to_user_id, amount)
    values ('TRANSFER'::public.transaction_type_enum, auth.uid(), p_receiver_id, p_amount);
  end if;
  
  return 'Success';
end;
$$;
comment on function public.send_message_and_coins(uuid, text, numeric) is 'Sends a chat message and optionally transfers coins.';


-- Game Logic RPCs
create or replace function public.add_upcoming_fight(p_red_text text, p_white_text text)
returns void
language plpgsql
as $$
begin
  insert into public.upcoming_fights (participants)
  values (jsonb_build_object('red', p_red_text, 'white', p_white_text));
end;
$$;
comment on function public.add_upcoming_fight(text, text) is 'Adds a new fight to the queue.';

create or replace function public.start_next_fight()
returns void
language plpgsql
as $$
declare
  next_fight public.upcoming_fights;
begin
  select * into next_fight from public.upcoming_fights order by id limit 1;
  if next_fight is not null then
    insert into public.fights (id, participants) values (next_fight.id, next_fight.participants);
    delete from public.upcoming_fights where id = next_fight.id;
  end if;
end;
$$;
comment on function public.start_next_fight is 'Starts the next fight from the queue.';

create or replace function public.close_betting(p_fight_id integer)
returns void
language plpgsql
as $$
begin
  update public.fights set status = 'BETTING_CLOSED'::public.fight_status_enum where id = p_fight_id and status = 'BETTING_OPEN'::public.fight_status_enum;
end;
$$;
comment on function public.close_betting(integer) is 'Closes betting for a specific fight.';

create or replace function public.place_bet(p_fight_id int, p_amount numeric, p_choice public.bet_choice_enum)
returns text
language plpgsql
as $$
declare
  player_profile public.profiles;
  current_fight public.fights;
begin
  select * into player_profile from public.profiles where id = auth.uid() for update;
  select * into current_fight from public.fights where id = p_fight_id;

  if current_fight.status <> 'BETTING_OPEN'::public.fight_status_enum then return 'Error: Betting is closed.'; end if;
  if player_profile.coin_balance < p_amount then return 'Error: Insufficient balance.'; end if;

  update public.profiles set coin_balance = coin_balance - p_amount where id = auth.uid();
  insert into public.bets (user_id, fight_id, amount, choice) values (auth.uid(), p_fight_id, p_amount, p_choice);
  
  insert into public.transactions (type, from_user_id, to_user_id, amount)
  values ('BET'::public.transaction_type_enum, auth.uid(), null, p_amount);

  return 'Success';
end;
$$;
comment on function public.place_bet(integer, numeric, public.bet_choice_enum) is 'Allows a player to place a bet.';


create or replace function public.declare_winner(p_fight_id integer, p_winner_text public.winner_enum)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  winning_bet record;
  total_commission numeric := 0;
  total_pool numeric;
  winning_pool numeric;
  payout_ratio numeric;
  player_profit numeric;
  agent_commission numeric;
  master_agent_commission numeric;
  player_record public.profiles;
  agent_record public.profiles;
begin
  update public.fights set winner = p_winner_text, status = 'SETTLED'::public.fight_status_enum, settled_at = now() where id = p_fight_id;

  if p_winner_text = 'DRAW'::public.winner_enum or p_winner_text = 'CANCELLED'::public.winner_enum then
    -- Refund all bets
    for winning_bet in select * from public.bets where fight_id = p_fight_id loop
      update public.profiles set coin_balance = coin_balance + winning_bet.amount where id = winning_bet.user_id;
      insert into public.transactions (type, from_user_id, to_user_id, amount)
      values ('REFUND'::public.transaction_type_enum, null, winning_bet.user_id, winning_bet.amount);
    end loop;
    return;
  end if;

  select sum(amount) into total_pool from public.bets where fight_id = p_fight_id;
  select sum(amount) into winning_pool from public.bets where fight_id = p_fight_id and choice = p_winner_text::public.bet_choice_enum;

  if winning_pool > 0 then
    payout_ratio := total_pool / winning_pool;

    for winning_bet in select * from public.bets where fight_id = p_fight_id and choice = p_winner_text::public.bet_choice_enum loop
      select * into player_record from public.profiles where id = winning_bet.user_id;
      
      player_profit := (winning_bet.amount * payout_ratio) - winning_bet.amount;
      agent_commission := player_profit * player_record.commission_rate;
      master_agent_commission := 0; -- Simplified for now

      -- Pay player
      update public.profiles set coin_balance = coin_balance + (winning_bet.amount + player_profit - agent_commission) where id = winning_bet.user_id;
      insert into public.transactions (type, from_user_id, to_user_id, amount)
      values ('WINNING'::public.transaction_type_enum, null, winning_bet.user_id, (winning_bet.amount + player_profit - agent_commission));

      -- Pay agent
      if player_record.agent_id is not null then
        update public.profiles set commission_balance = commission_balance + agent_commission where id = player_record.agent_id;
        insert into public.transactions (type, from_user_id, to_user_id, amount)
        values ('COMMISSION'::public.transaction_type_enum, winning_bet.user_id, player_record.agent_id, agent_commission);
        total_commission := total_commission + agent_commission;

        -- Pay master agent
        select * into agent_record from public.profiles where id = player_record.agent_id;
        if agent_record.master_agent_id is not null then
           master_agent_commission := player_profit * (select commission_rate from public.profiles where id = agent_record.master_agent_id);
           update public.profiles set commission_balance = commission_balance + master_agent_commission where id = agent_record.master_agent_id;
           insert into public.transactions (type, from_user_id, to_user_id, amount)
           values ('COMMISSION'::public.transaction_type_enum, winning_bet.user_id, agent_record.master_agent_id, master_agent_commission);
           total_commission := total_commission + master_agent_commission;
        end if;
      end if;
    end loop;
  end if;

  -- Update total commission for the fight
  update public.fights set commission = total_commission where id = p_fight_id;
end;
$$;
comment on function public.declare_winner(integer, public.winner_enum) is 'Settles a fight, pays winners, and distributes commissions.';


-- END OF SCRIPT --