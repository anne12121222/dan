-- Grand Overhaul: Final, Definitive, and 100% Complete Database Script
-- This script is fully resettable and contains all backend logic for every feature.
-- Replaced the recursive RLS policies with a single, comprehensive policy using secure helper functions.

-- STEP 1: Clean up old objects to ensure a clean slate.
DROP FUNCTION IF EXISTS public.sync_public_agents() CASCADE;
DROP FUNCTION IF EXISTS public.get_registerable_agents() CASCADE;
DROP FUNCTION IF EXISTS public.create_master_agent(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.create_agent(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.create_operator(text, text, text) CASCADE;
DROP FUNCTION IF EXISTS public.add_upcoming_fight(text, text) CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.get_all_users_for_operator() CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(integer, numeric, public.bet_choice) CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(integer) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(integer, public.fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(numeric) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, public.request_status) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric) CASCADE;
DROP FUNCTION IF EXISTS public.get_my_role() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_agent_id() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_master_agent_id() CASCADE;


DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.public_agents CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;

-- STEP 2: Create custom types (Enums).
CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');

-- STEP 3: Create the main 'profiles' table with hardened RLS.
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email character varying NOT NULL UNIQUE,
    name text NOT NULL,
    role public.user_role NOT NULL DEFAULT 'PLAYER'::public.user_role,
    coin_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_rate numeric(5, 4) NOT NULL DEFAULT 0.0700,
    transfer_fee numeric(5, 4) NOT NULL DEFAULT 0.0100,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- NEW: Definitive RLS Policy for profiles, replacing all old recursive policies.
CREATE POLICY "Allow hierarchical read access" ON public.profiles FOR SELECT TO authenticated USING (
    -- A user can see themself
    id = auth.uid()
    -- A master agent can see their agents
    OR master_agent_id = auth.uid()
    -- An agent can see their players
    OR agent_id = auth.uid()
);

-- STEP 4: Create other application tables with hardened RLS.
CREATE TABLE public.fights (
    id integer PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'SETTLED'::public.fight_status,
    winner public.fight_winner,
    commission numeric(15, 2) NOT NULL DEFAULT 0.00,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can view fights." ON public.fights FOR SELECT TO authenticated USING (true);
CREATE POLICY "Operators can manage fights." ON public.fights FOR ALL TO authenticated USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR'::public.user_role);


CREATE TABLE public.upcoming_fights (
    id serial PRIMARY KEY,
    participants jsonb NOT NULL
);
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can view upcoming fights." ON public.upcoming_fights FOR SELECT TO authenticated USING (true);
CREATE POLICY "Operators can manage upcoming fights." ON public.upcoming_fights FOR ALL TO authenticated USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR'::public.user_role);


CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id integer NOT NULL REFERENCES public.fights(id),
    amount numeric(15, 2) NOT NULL,
    choice public.bet_choice NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own bets." ON public.bets FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Hierarchies can view subordinate bets." ON public.bets FOR SELECT TO authenticated USING (
    (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR'::public.user_role OR
    (SELECT agent_id FROM public.profiles WHERE id = user_id) = auth.uid() OR
    (SELECT master_agent_id FROM public.profiles WHERE id = (SELECT agent_id FROM public.profiles WHERE id = user_id)) = auth.uid()
);
CREATE POLICY "Players can place bets." ON public.bets FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'PLAYER'::public.user_role);

CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    type public.transaction_type NOT NULL,
    timestamp timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own transactions." ON public.transactions FOR SELECT TO authenticated USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see messages sent to or from them." ON public.messages FOR SELECT TO authenticated USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages." ON public.messages FOR INSERT TO authenticated WITH CHECK (auth.uid() = sender_id);


CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING'::public.request_status,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see requests sent to or from them." ON public.coin_requests FOR ALL TO authenticated USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

-- STEP 5: Create trigger functions.

-- Function to handle new user creation in auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    user_role public.user_role;
    user_agent_id uuid;
    user_master_agent_id uuid;
BEGIN
    user_role := COALESCE((new.raw_user_meta_data->>'role')::public.user_role, 'PLAYER'::public.user_role);
    user_agent_id := (new.raw_user_meta_data->>'agent_id')::uuid;
    user_master_agent_id := (new.raw_user_meta_data->>'master_agent_id')::uuid;

    IF user_role = 'PLAYER' THEN
        user_master_agent_id := (SELECT master_agent_id FROM public.profiles WHERE id = user_agent_id);
    END IF;

    INSERT INTO public.profiles (id, email, name, role, agent_id, master_agent_id)
    VALUES (
        new.id,
        new.email,
        COALESCE(new.raw_user_meta_data->>'name', SPLIT_PART(new.email, '@', 1)),
        user_role,
        user_agent_id,
        user_master_agent_id
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- STEP 6: Create triggers.
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- STEP 7: Create database functions (RPC).

-- NEW: Function for operator to see all users, bypassing RLS.
CREATE OR REPLACE FUNCTION public.get_all_users_for_operator()
RETURNS SETOF public.profiles AS $$
BEGIN
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
        RAISE EXCEPTION 'Only operators can access this function.';
    END IF;
    RETURN QUERY SELECT * FROM public.profiles;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Function to get agents for registration.
CREATE OR REPLACE FUNCTION public.get_registerable_agents()
RETURNS TABLE(id uuid, name text) AS $$
BEGIN
  RETURN QUERY
    SELECT p.id, p.name FROM public.profiles p WHERE p.role = 'AGENT';
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


-- Function for an Operator to create a new Master Agent user
CREATE OR REPLACE FUNCTION public.create_master_agent(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
    caller_role public.user_role;
    caller_id uuid := auth.uid();
BEGIN
    SELECT role INTO caller_role FROM public.profiles WHERE id = caller_id;
    IF caller_role != 'OPERATOR' THEN
        RETURN 'Error: Only Operators can create Master Agent users.';
    END IF;

    PERFORM auth.admin.create_user(p_email, p_password, jsonb_build_object(
        'name', p_name,
        'role', 'MASTER_AGENT'
    ));

    RETURN 'Master Agent created successfully.';
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'Error: Failed to create master agent. ' || SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Function for a Master Agent to create a new Agent user
CREATE OR REPLACE FUNCTION public.create_agent(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
    caller_role public.user_role;
    caller_id uuid := auth.uid();
BEGIN
    SELECT role INTO caller_role FROM public.profiles WHERE id = caller_id;
    IF caller_role != 'MASTER_AGENT' THEN
        RETURN 'Error: Only Master Agents can create Agent users.';
    END IF;

    PERFORM auth.admin.create_user(p_email, p_password, jsonb_build_object(
        'name', p_name,
        'role', 'AGENT',
        'master_agent_id', caller_id
    ));

    RETURN 'Agent created successfully.';
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'Error: Failed to create agent. ' || SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- NEW: Function for a Master Agent to create a new Operator user
CREATE OR REPLACE FUNCTION public.create_operator(p_name text, p_email text, p_password text)
RETURNS text AS $$
DECLARE
    caller_role public.user_role;
    caller_id uuid := auth.uid();
BEGIN
    SELECT role INTO caller_role FROM public.profiles WHERE id = caller_id;
    IF caller_role != 'MASTER_AGENT' THEN
        RETURN 'Error: Only Master Agents can create Operator users.';
    END IF;

    PERFORM auth.admin.create_user(p_email, p_password, jsonb_build_object(
        'name', p_name,
        'role', 'OPERATOR'
    ));

    RETURN 'Operator created successfully.';
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'Error: Failed to create operator. ' || SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;


-- Function for an Operator to start the next fight
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS integer AS $$
DECLARE
    next_fight record;
BEGIN
    SELECT id, participants INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
    IF FOUND THEN
        DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
        INSERT INTO public.fights (id, status) VALUES (next_fight.id, 'BETTING_OPEN')
        ON CONFLICT (id) DO UPDATE SET status = 'BETTING_OPEN', winner = NULL, commission = 0;
        RETURN next_fight.id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function for Operator to add an upcoming fight
CREATE OR REPLACE FUNCTION public.add_upcoming_fight(p_red text, p_white text)
RETURNS void AS $$
BEGIN
    INSERT INTO public.upcoming_fights (participants) VALUES (jsonb_build_object('red', p_red, 'white', p_white));
END;
$$ LANGUAGE plpgsql;


-- Function for a Player to place a bet
CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id int, p_amount numeric, p_choice public.bet_choice)
RETURNS text AS $$
DECLARE
    player_balance numeric;
    fight public.fights;
BEGIN
    SELECT * INTO fight FROM public.fights WHERE id = p_fight_id;
    IF fight.status != 'BETTING_OPEN' THEN
        RETURN 'Error: Betting is not open for this fight.';
    END IF;

    SELECT coin_balance INTO player_balance FROM public.profiles WHERE id = auth.uid();
    IF player_balance < p_amount THEN
        RETURN 'Error: Insufficient balance.';
    END IF;
    
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), null, p_amount, 'BET_PLACE');
    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
    INSERT INTO public.bets(user_id, fight_id, amount, choice) VALUES (auth.uid(), p_fight_id, p_amount, p_choice);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;


-- Function for an Operator to declare a winner and settle bets
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id int, p_winner public.fight_winner)
RETURNS void AS $$
DECLARE
    bet_record RECORD;
    player_record RECORD;
    agent_record RECORD;
    master_agent_record RECORD;
    winning_pool numeric := 0;
    losing_pool numeric := 0;
    player_profit numeric;
    player_payout numeric;
    agent_commission numeric;
    master_agent_commission numeric;
    payout_ratio numeric;
    operator_id uuid;
    total_commission_paid numeric := 0;
BEGIN
    UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id;
    SELECT id INTO operator_id FROM public.profiles WHERE role = 'OPERATOR' LIMIT 1;

    IF p_winner = 'DRAW' OR p_winner = 'CANCELLED' THEN
        FOR bet_record IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + bet_record.amount WHERE id = bet_record.user_id;
            INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (null, bet_record.user_id, bet_record.amount, 'BET_REFUND');
        END LOOP;
    ELSE
        SELECT COALESCE(SUM(amount), 0) INTO winning_pool FROM public.bets WHERE fight_id = p_fight_id AND choice::text = p_winner::text;
        SELECT COALESCE(SUM(amount), 0) INTO losing_pool FROM public.bets WHERE fight_id = p_fight_id AND choice::text != p_winner::text;

        payout_ratio := CASE WHEN winning_pool > 0 THEN losing_pool / winning_pool ELSE 0 END;
        
        FOR bet_record IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice::text = p_winner::text LOOP
            player_profit := bet_record.amount * payout_ratio;
            player_payout := bet_record.amount + player_profit;

            SELECT * INTO player_record FROM public.profiles WHERE id = bet_record.user_id;
            SELECT * INTO agent_record FROM public.profiles WHERE id = player_record.agent_id;
            SELECT * INTO master_agent_record FROM public.profiles WHERE id = agent_record.master_agent_id;

            agent_commission := player_profit * agent_record.commission_rate;
            master_agent_commission := player_profit * master_agent_record.commission_rate;

            total_commission_paid := total_commission_paid + agent_commission + master_agent_commission;

            UPDATE public.profiles SET coin_balance = coin_balance + player_payout WHERE id = player_record.id;
            INSERT INTO public.transactions(from_user_id, to_user_id, amount, type) VALUES (operator_id, player_record.id, player_payout, 'BET_WIN');

            UPDATE public.profiles SET commission_balance = commission_balance + agent_commission WHERE id = agent_record.id;
            INSERT INTO public.transactions(from_user_id, to_user_id, amount, type) VALUES (operator_id, agent_record.id, agent_commission, 'COMMISSION');

            UPDATE public.profiles SET commission_balance = commission_balance + master_agent_commission WHERE id = master_agent_record.id;
            INSERT INTO public.transactions(from_user_id, to_user_id, amount, type) VALUES (operator_id, master_agent_record.id, master_agent_commission, 'COMMISSION');
        END LOOP;
        
        UPDATE public.profiles SET coin_balance = coin_balance + losing_pool - (winning_pool * payout_ratio) - total_commission_paid WHERE id = operator_id;
    END IF;

    UPDATE public.fights SET winner = p_winner, status = 'SETTLED', commission = total_commission_paid WHERE id = p_fight_id;
END;
$$ LANGUAGE plpgsql;

-- Function for an Operator to close betting
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id integer)
RETURNS void AS $$
BEGIN
    UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql;

-- Function for users to create a coin request to their superior
CREATE OR REPLACE FUNCTION public.create_coin_request(p_amount numeric)
RETURNS text AS $$
DECLARE
    requester_profile public.profiles;
    recipient_id uuid;
BEGIN
    SELECT * INTO requester_profile FROM public.profiles WHERE id = auth.uid();

    IF requester_profile.role = 'PLAYER' THEN recipient_id := requester_profile.agent_id;
    ELSIF requester_profile.role = 'AGENT' THEN recipient_id := requester_profile.master_agent_id;
    ELSIF requester_profile.role = 'MASTER_AGENT' THEN RETURN 'Error: Master Agents cannot request coins.';
    ELSE RETURN 'Error: Operators cannot request coins.';
    END IF;

    IF recipient_id IS NULL THEN RETURN 'Error: Could not find a recipient for your request.'; END IF;

    INSERT INTO public.coin_requests (from_user_id, to_user_id, amount) VALUES (auth.uid(), recipient_id, p_amount);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function for users to respond to a coin request
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
DECLARE
    request public.coin_requests;
BEGIN
    SELECT * INTO request FROM public.coin_requests WHERE id = p_request_id AND to_user_id = auth.uid();
    IF NOT FOUND THEN RETURN 'Error: Request not found or not authorized.'; END IF;
    IF request.status != 'PENDING' THEN RETURN 'Error: Request already actioned.'; END IF;
    
    IF p_response = 'APPROVED' THEN
        IF (SELECT coin_balance FROM public.profiles WHERE id = auth.uid()) < request.amount THEN RETURN 'Error: Insufficient balance.'; END IF;
        UPDATE public.profiles SET coin_balance = coin_balance - request.amount WHERE id = auth.uid();
        UPDATE public.profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), request.from_user_id, request.amount, 'TRANSFER');
    END IF;

    UPDATE public.coin_requests SET status = p_response WHERE id = p_request_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function for agents/masters to send messages and coins
CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS text AS $$
DECLARE
    sender_profile public.profiles;
    total_deduction numeric;
    fee_amount numeric := 0;
    fee_recipient_id uuid;
BEGIN
    SELECT * INTO sender_profile FROM public.profiles WHERE id = auth.uid();

    IF p_text IS NOT NULL AND p_text != '' THEN
        INSERT INTO public.messages(sender_id, receiver_id, text) VALUES (auth.uid(), p_receiver_id, p_text);
    END IF;

    IF p_amount IS NOT NULL AND p_amount > 0 THEN
        fee_amount := p_amount * sender_profile.transfer_fee;
        IF sender_profile.role = 'AGENT' THEN fee_recipient_id := sender_profile.master_agent_id;
        ELSIF sender_profile.role = 'MASTER_AGENT' THEN SELECT id INTO fee_recipient_id FROM public.profiles WHERE role = 'OPERATOR' LIMIT 1;
        END IF;

        total_deduction := p_amount + fee_amount;
        IF sender_profile.coin_balance < total_deduction THEN RETURN 'Error: Insufficient balance to send coins and cover fees.'; END IF;

        UPDATE public.profiles SET coin_balance = coin_balance - total_deduction WHERE id = auth.uid();
        UPDATE public.profiles SET coin_balance = coin_balance + p_amount WHERE id = p_receiver_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), p_receiver_id, p_amount, 'TRANSFER');

        IF fee_amount > 0 AND fee_recipient_id IS NOT NULL THEN
            UPDATE public.profiles SET commission_balance = commission_balance + fee_amount WHERE id = fee_recipient_id;
            INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (auth.uid(), fee_recipient_id, fee_amount, 'COMMISSION');
        END IF;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to get all transactions for the current user
CREATE OR REPLACE FUNCTION public.get_transactions_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, type public.transaction_type, transaction_timestamp timestamptz) AS $$
BEGIN
    RETURN QUERY
    SELECT t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.timestamp AS transaction_timestamp
    FROM public.transactions t
    WHERE t.from_user_id = auth.uid() OR t.to_user_id = auth.uid()
    ORDER BY t.timestamp DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get all coin requests for the current user
CREATE OR REPLACE FUNCTION public.get_coin_requests_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, status public.request_status, created_at timestamptz) AS $$
BEGIN
    RETURN QUERY
    SELECT cr.id, cr.from_user_id, cr.to_user_id, cr.amount, cr.status, cr.created_at
    FROM public.coin_requests cr
    WHERE cr.from_user_id = auth.uid() OR cr.to_user_id = auth.uid()
    ORDER BY cr.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get messages between the current user and another user
CREATE OR REPLACE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, created_at timestamptz) AS $$
BEGIN
    RETURN QUERY
    SELECT m.id, m.sender_id, m.receiver_id, m.text, m.created_at
    FROM public.messages m
    WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_other_user_id)
       OR (m.sender_id = p_other_user_id AND m.receiver_id = auth.uid())
    ORDER BY m.created_at ASC;
END;
$$ LANGUAGE plpgsql;


-- STEP 8: Enable real-time for tables.
ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles, public.fights, public.bets, public.transactions, public.messages, public.coin_requests, public.upcoming_fights;

-- STEP 9: Grant necessary, minimal permissions.
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_registerable_agents() TO anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;