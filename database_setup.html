-- =================================================================================================
-- Reality Boxing - Betting Platform Schema & Access-Control Logic
-- =================================================================================================
-- This script is designed to be idempotent. It can be run multiple times safely.
-- It will clean up the existing schema and rebuild it from scratch.
-- =================================================================================================

-- =================================================================================================
-- 0. INITIAL CLEANUP
-- =================================================================================================
-- Drop existing policies and RLS
DO $$
DECLARE
    table_record RECORD;
    policy_record RECORD;
BEGIN
    FOR table_record IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(table_record.tablename) || ' DISABLE ROW LEVEL SECURITY;';
        -- Drop all policies for the table
        FOR policy_record IN (SELECT policyname FROM pg_policies WHERE schemaname = 'public' AND tablename = table_record.tablename) LOOP
            EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_record.policyname) || ' ON public.' || quote_ident(table_record.tablename) || ';';
        END LOOP;
    END LOOP;
END $$;

-- Drop dependent objects first
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop functions
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.handle_new_player(text,text,text,uuid);
DROP FUNCTION IF EXISTS public.create_user_by_master_agent(text,text,text,public.user_role,uuid);
DROP FUNCTION IF EXISTS public.start_next_fight();
DROP FUNCTION IF EXISTS public.close_betting(bigint);
DROP FUNCTION IF EXISTS public.declare_winner(bigint,public.fight_winner);
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid,text);
DROP FUNCTION IF EXISTS public.send_message(uuid,text,numeric);
DROP FUNCTION IF EXISTS public.get_player_fight_history(uuid);
DROP FUNCTION IF EXISTS public.get_user_transactions(uuid);
DROP FUNCTION IF EXISTS public.get_agent_requests_for_master(uuid);
DROP FUNCTION IF EXISTS public.get_messages(uuid,uuid);


-- Drop tables
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop enums
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;

-- =================================================================================================
-- 1. TYPE DEFINITIONS (ENUMS)
-- =================================================================================================
CREATE TYPE public.user_role AS ENUM ('PLAYER', 'AGENT', 'MASTER_AGENT', 'OPERATOR');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('MINT', 'TRANSFER', 'COMMISSION', 'BET', 'WINNING', 'REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- =================================================================================================
-- 2. TABLE CREATION
-- =================================================================================================

-- Profiles table to store user data extending the auth.users table
CREATE TABLE public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    role public.user_role NOT NULL,
    coin_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id),
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_rate real NOT NULL DEFAULT 0.07,
    transfer_fee real NOT NULL DEFAULT 0.01,
    CONSTRAINT coin_balance_non_negative CHECK (coin_balance >= 0)
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing user profile information.';

-- Fights table
CREATE TABLE public.fights (
    id bigserial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'SETTLED',
    winner public.fight_winner,
    betting_ends_at timestamptz,
    commission numeric(15, 2),
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.fights IS 'Stores the state of each fight, including status and winner.';

-- Upcoming Fights Queue
CREATE TABLE public.upcoming_fights (
    id bigserial PRIMARY KEY,
    red_participant text NOT NULL,
    white_participant text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.upcoming_fights IS 'A queue of fights waiting to be started by the operator.';

-- Bets table
CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id bigint NOT NULL REFERENCES public.fights(id),
    amount numeric(15, 2) NOT NULL,
    choice public.bet_choice NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE(user_id, fight_id), -- A user can only place one bet per fight
    CONSTRAINT amount_positive CHECK (amount > 0)
);
COMMENT ON TABLE public.bets IS 'Stores individual bets placed by players on fights.';

-- Transactions table
CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    type public.transaction_type NOT NULL,
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    transaction_timestamp timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.transactions IS 'Logs all coin movements between users and the system.';

-- Messages table
CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.messages IS 'Stores chat messages between users.';

-- Coin Requests table
CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.coin_requests IS 'Manages coin transfer requests between users.';


-- =================================================================================================
-- 3. AUTH TRIGGERS & FUNCTIONS
-- =================================================================================================
-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, role, agent_id)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'name', new.email), -- Use name from metadata or fallback to email
    new.email,
    'PLAYER', -- Default role for self-signup
    (new.raw_user_meta_data->>'agent_id')::uuid
  );
  RETURN new;
END;
$$;

-- Trigger to call the function when a new user signs up
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =================================================================================================
-- 4. RPC FUNCTIONS (Stored Procedures)
-- =================================================================================================

-- Function for a player to self-register
CREATE OR REPLACE FUNCTION public.handle_new_player(name text, email text, password text, agent_id uuid)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  new_user_id uuid;
BEGIN
  new_user_id := auth.signup(email, password, jsonb_build_object('name', name, 'agent_id', agent_id));
  RETURN new_user_id;
END;
$$;

-- Function for a Master Agent to create other users
CREATE OR REPLACE FUNCTION public.create_user_by_master_agent(name text, email text, password text, role public.user_role, master_agent_id uuid)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  new_user_id uuid;
  current_user_role public.user_role;
BEGIN
  -- Security check: only Master Agents can call this
  SELECT p.role INTO current_user_role FROM public.profiles p WHERE p.id = auth.uid();
  IF current_user_role <> 'MASTER_AGENT' THEN
    RAISE EXCEPTION 'Permission denied: Only Master Agents can create users.';
  END IF;

  -- Create the user in auth.users
  new_user_id := auth.signup(email, password, jsonb_build_object('name', name));
  
  -- Update the created user's profile with the correct role and MA
  UPDATE public.profiles
  SET 
    role = create_user_by_master_agent.role,
    master_agent_id = CASE 
                        WHEN create_user_by_master_agent.role = 'AGENT' THEN create_user_by_master_agent.master_agent_id 
                        ELSE NULL 
                      END,
    agent_id = NULL -- Agents/Operators/MAs don't have agents
  WHERE id = new_user_id;

  RETURN new_user_id;
END;
$$;


-- Function to start the next fight from the queue
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  next_fight record;
BEGIN
  -- Get the next fight from the queue
  SELECT * INTO next_fight FROM upcoming_fights ORDER BY id ASC LIMIT 1;

  IF next_fight IS NOT NULL THEN
    -- Create a new fight in the main fights table
    INSERT INTO fights (id, status, betting_ends_at)
    VALUES (next_fight.id, 'BETTING_OPEN', now() + interval '60 seconds');

    -- Remove it from the queue
    DELETE FROM upcoming_fights WHERE id = next_fight.id;
  END IF;
END;
$$;

-- Function to close betting for a fight
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE fights
  SET status = 'BETTING_CLOSED'
  WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$;

-- Function to declare a winner and distribute winnings
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id bigint, p_winner public.fight_winner)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    total_pool numeric;
    winner_pool numeric;
    loser_pool numeric;
    total_commission numeric;
    winner_choice public.bet_choice;
    winning_bet record;
    payout_amount numeric;
    player_share numeric;
BEGIN
    -- Update fight status
    UPDATE fights SET status = 'SETTLED', winner = p_winner WHERE id = p_fight_id;

    -- Handle DRAW or CANCELLED cases by refunding all bets
    IF p_winner = 'DRAW' OR p_winner = 'CANCELLED' THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('REFUND', winning_bet.user_id, winning_bet.amount);
        END LOOP;
        RETURN;
    END IF;

    -- Handle a conclusive winner (RED or WHITE)
    winner_choice := CASE WHEN p_winner = 'RED' THEN 'RED'::public.bet_choice ELSE 'WHITE'::public.bet_choice END;

    -- Calculate pools
    SELECT COALESCE(SUM(amount), 0) INTO total_pool FROM public.bets WHERE fight_id = p_fight_id;
    SELECT COALESCE(SUM(amount), 0) INTO winner_pool FROM public.bets WHERE fight_id = p_fight_id AND choice = winner_choice;
    loser_pool := total_pool - winner_pool;

    -- Calculate total commission (e.g., 10% of the losing pool)
    total_commission := loser_pool * 0.10;
    UPDATE fights SET commission = total_commission WHERE id = p_fight_id;

    -- Distribute winnings to players
    IF winner_pool > 0 THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = winner_choice LOOP
            -- Calculate player's share of the winner pool
            player_share := winning_bet.amount / winner_pool;
            -- Payout includes original bet + share of the loser pool minus commission
            payout_amount := winning_bet.amount + (player_share * (loser_pool - total_commission));

            UPDATE public.profiles SET coin_balance = coin_balance + payout_amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('WINNING', winning_bet.user_id, payout_amount);
        END LOOP;
    END IF;

END;
$$;

-- Function to respond to a coin request
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
  request record;
  approver_profile record;
BEGIN
  SELECT * INTO request FROM coin_requests WHERE id = p_request_id AND status = 'PENDING';
  
  IF request IS NULL THEN
    RAISE EXCEPTION 'Request not found or already handled.';
  END IF;

  -- Ensure the person responding is the one the request was sent to
  IF request.to_user_id <> auth.uid() THEN
    RAISE EXCEPTION 'Permission denied to respond to this request.';
  END IF;

  SELECT * INTO approver_profile FROM profiles WHERE id = request.to_user_id;

  IF p_response = 'APPROVED' THEN
    -- Check if approver has enough balance
    IF approver_profile.coin_balance < request.amount THEN
      RAISE EXCEPTION 'Insufficient balance to approve request.';
    END IF;
    
    -- Perform the transfer
    UPDATE profiles SET coin_balance = coin_balance - request.amount WHERE id = request.to_user_id;
    UPDATE profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;
    
    -- Create a transaction log
    INSERT INTO transactions (type, from_user_id, to_user_id, amount)
    VALUES ('TRANSFER', request.to_user_id, request.from_user_id, request.amount);

    -- Update request status
    UPDATE coin_requests SET status = 'APPROVED' WHERE id = p_request_id;

    -- Handle adoption logic: If a player/agent is unassigned, assign them to the approver
    UPDATE profiles SET 
      agent_id = CASE WHEN role = 'PLAYER' AND agent_id IS NULL THEN request.to_user_id ELSE agent_id END,
      master_agent_id = CASE WHEN role = 'AGENT' AND master_agent_id IS NULL THEN request.to_user_id ELSE master_agent_id END
    WHERE id = request.from_user_id;
    
  ELSE -- Declined
    UPDATE coin_requests SET status = 'DECLINED' WHERE id = p_request_id;
  END IF;
END;
$$;


-- Function to send a message (and optionally coins)
CREATE OR REPLACE FUNCTION public.send_message(p_receiver_id uuid, p_text text, p_coin_amount numeric)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
  sender_id uuid := auth.uid();
  sender_balance numeric;
BEGIN
  -- Insert the message
  INSERT INTO messages (sender_id, receiver_id, text) VALUES (sender_id, p_receiver_id, p_text);

  -- Handle coin transfer if amount is greater than 0
  IF p_coin_amount > 0 THEN
    SELECT coin_balance INTO sender_balance FROM profiles WHERE id = sender_id;
    IF sender_balance < p_coin_amount THEN
      RAISE EXCEPTION 'Insufficient balance to send coins.';
    END IF;

    UPDATE profiles SET coin_balance = coin_balance - p_coin_amount WHERE id = sender_id;
    UPDATE profiles SET coin_balance = coin_balance + p_coin_amount WHERE id = p_receiver_id;

    INSERT INTO transactions (type, from_user_id, to_user_id, amount)
    VALUES ('TRANSFER', sender_id, p_receiver_id, p_coin_amount);
  END IF;
END;
$$;


-- Data retrieval functions
CREATE OR REPLACE FUNCTION public.get_player_fight_history(p_user_id uuid)
RETURNS TABLE(id bigint, winner public.fight_winner, commission numeric, bet json, outcome text)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT 
    f.id, 
    f.winner, 
    f.commission, 
    (SELECT row_to_json(b) FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) as bet,
    CASE 
      WHEN (SELECT b.choice::text FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = f.winner::text THEN 'WIN'
      WHEN f.winner IN ('DRAW', 'CANCELLED') AND (SELECT 1 FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'REFUND'
      WHEN (SELECT 1 FROM bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'LOSS'
      ELSE NULL
    END as outcome
  FROM fights f
  WHERE f.status = 'SETTLED'
  ORDER BY f.id DESC;
$$;

CREATE OR REPLACE FUNCTION public.get_user_transactions(p_user_id uuid)
RETURNS SETOF transactions
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT * FROM transactions
  WHERE from_user_id = p_user_id OR to_user_id = p_user_id
  ORDER BY transaction_timestamp DESC;
$$;

CREATE OR REPLACE FUNCTION public.get_agent_requests_for_master(p_master_agent_id uuid)
RETURNS SETOF coin_requests
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT cr.* 
  FROM coin_requests cr
  JOIN profiles agent_profile ON cr.from_user_id = agent_profile.id
  WHERE agent_profile.master_agent_id = p_master_agent_id AND cr.status = 'PENDING';
$$;

CREATE OR REPLACE FUNCTION public.get_messages(user1_id uuid, user2_id uuid)
RETURNS SETOF messages
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT * FROM messages
  WHERE (sender_id = user1_id AND receiver_id = user2_id)
     OR (sender_id = user2_id AND receiver_id = user1_id)
  ORDER BY created_at ASC;
$$;


-- =================================================================================================
-- 5. ROW-LEVEL SECURITY (RLS) POLICIES
-- =================================================================================================
-- Enable RLS for all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;

-- PROFILES Policies
CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- FIGHTS Policies
CREATE POLICY "All users can view fights" ON public.fights FOR SELECT USING (true);
CREATE POLICY "Operators can insert/update fights" ON public.fights FOR ALL USING ( (SELECT role FROM profiles WHERE id = auth.uid()) = 'OPERATOR' );

-- UPCOMING_FIGHTS Policies
CREATE POLICY "All users can view upcoming fights" ON public.upcoming_fights FOR SELECT USING (true);
CREATE POLICY "Operators can manage the fight queue" ON public.upcoming_fights FOR ALL USING ( (SELECT role FROM profiles WHERE id = auth.uid()) = 'OPERATOR' );

-- BETS Policies
CREATE POLICY "Users can view all bets on active fights" ON public.bets FOR SELECT USING (true);
CREATE POLICY "Players can place bets" ON public.bets FOR INSERT WITH CHECK ( (SELECT role FROM profiles WHERE id = auth.uid()) = 'PLAYER' AND user_id = auth.uid() );

-- TRANSACTIONS Policies
CREATE POLICY "Users can view their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

-- MESSAGES Policies
CREATE POLICY "Users can view their own messages" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- COIN_REQUESTS Policies
CREATE POLICY "Users can view requests they sent or received" ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can create coin requests" ON public.coin_requests FOR INSERT WITH CHECK (auth.uid() = from_user_id);

-- =================================================================================================
-- 6. REAL-TIME CONFIGURATION
-- =================================================================================================
-- Set REPLICA IDENTITY to FULL for tables that need real-time updates with RLS
ALTER TABLE public.profiles REPLICA IDENTITY FULL;
ALTER TABLE public.fights REPLICA IDENTITY FULL;
ALTER TABLE public.upcoming_fights REPLICA IDENTITY FULL;
ALTER TABLE public.bets REPLICA IDENTITY FULL;
ALTER TABLE public.transactions REPLICA IDENTITY FULL;
ALTER TABLE public.coin_requests REPLICA IDENTITY FULL;
ALTER TABLE public.messages REPLICA IDENTITY FULL;

-- Add tables to the publication for real-time updates
DROP PUBLICATION IF EXISTS supabase_realtime;
CREATE PUBLICATION supabase_realtime FOR ALL TABLES;

-- Note: In newer Supabase projects, you might add tables individually.
-- The command above is a broad but effective approach. For finer control:
-- CREATE PUBLICATION supabase_realtime;
-- ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
-- ALTER PUBLICATION supabase_realtime ADD TABLE public.fights;
-- etc.

-- =================================================================================================
-- END OF SCRIPT
-- =================================================================================================