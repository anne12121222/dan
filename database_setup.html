-- =============================================
-- 0. INITIAL CLEANUP
-- =============================================
-- Drop existing policies and RLS
DO $$
DECLARE
    table_record RECORD;
    policy_record RECORD;
BEGIN
    -- Loop through all tables in the public schema
    FOR table_record IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(table_record.tablename) || ' DISABLE ROW LEVEL SECURITY;';
        
        -- Loop through all policies on the current table and drop them
        FOR policy_record IN (SELECT policyname FROM pg_policies WHERE schemaname = 'public' AND tablename = table_record.tablename) LOOP
            EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_record.policyname) || ' ON public.' || quote_ident(table_record.tablename) || ';';
        END LOOP;
    END LOOP;
END $$;

-- Drop trigger before dropping its function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop functions to avoid conflicts
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.create_agent_user(text, text, text);
DROP FUNCTION IF EXISTS public.create_master_agent_user(text, text, text);
DROP FUNCTION IF EXISTS public.create_operator_user(text, text, text);
DROP FUNCTION IF EXISTS public.add_upcoming_fight(text, text);
DROP FUNCTION IF EXISTS public.start_next_fight();
DROP FUNCTION IF EXISTS public.close_betting(integer);
DROP FUNCTION IF EXISTS public.declare_winner(integer, text);
DROP FUNCTION IF EXISTS public.place_bet(integer, numeric, text);
DROP FUNCTION IF EXISTS public.create_coin_request(uuid, numeric);
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, text);
DROP FUNCTION IF EXISTS public.get_messages(uuid);
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric);

-- Drop tables in reverse order of dependency
DROP TABLE IF EXISTS public.messages;
DROP TABLE IF EXISTS public.transactions;
DROP TABLE IF EXISTS public.coin_requests;
DROP TABLE IF EXISTS public.bets;
DROP TABLE IF EXISTS public.upcoming_fights;
DROP TABLE IF EXISTS public.fights;
DROP TABLE IF EXISTS public.profiles;

-- Drop custom types
DROP TYPE IF EXISTS public.user_role;
DROP TYPE IF EXISTS public.fight_status;
DROP TYPE IF EXISTS public.bet_choice;
DROP TYPE IF EXISTS public.fight_winner;
DROP TYPE IF EXISTS public.transaction_type;
DROP TYPE IF EXISTS public.request_status;

-- =============================================
-- 1. CREATE ENUM TYPES
-- =============================================
CREATE TYPE public.user_role AS ENUM ('PLAYER', 'AGENT', 'MASTER_AGENT', 'OPERATOR');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('MINT', 'TRANSFER', 'COMMISSION', 'BET', 'WINNING', 'REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- =============================================
-- 2. CREATE TABLES
-- =============================================
-- Profiles Table (stores user-specific data)
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    role public.user_role NOT NULL,
    coin_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_rate numeric(5, 4) NOT NULL DEFAULT 0.0700,
    transfer_fee numeric(5, 4) NOT NULL DEFAULT 0.0100,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id)
);

-- Fights Table (stores active and past fights)
CREATE TABLE public.fights (
    id serial PRIMARY KEY,
    participants jsonb,
    status public.fight_status NOT NULL DEFAULT 'BETTING_OPEN',
    winner public.fight_winner,
    commission numeric(15, 2) NOT NULL DEFAULT 0.00,
    created_at timestamptz NOT NULL DEFAULT now(),
    settled_at timestamptz
);

-- Upcoming Fights Table (queue for future fights)
CREATE TABLE public.upcoming_fights (
    id serial PRIMARY KEY,
    participants jsonb NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Bets Table
CREATE TABLE public.bets (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id integer NOT NULL REFERENCES public.fights(id),
    amount numeric(15, 2) NOT NULL,
    choice public.bet_choice NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (user_id, fight_id) -- Ensure a user can only bet once per fight
);

-- Transactions Table
CREATE TABLE public.transactions (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    type public.transaction_type NOT NULL,
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    transaction_timestamp timestamptz NOT NULL DEFAULT now()
);

-- Coin Requests Table
CREATE TABLE public.coin_requests (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Messages Table
CREATE TABLE public.messages (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- =============================================
-- 3. TRIGGERS & FUNCTIONS
-- =============================================
-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, role, agent_id, coin_balance)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'name',
    new.email,
    'PLAYER',
    (new.raw_user_meta_data->>'agent_id')::uuid,
    100 -- Starting balance for new players
  );
  RETURN new;
END;
$$;

-- Trigger to call the function on new user signup
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =============================================
-- 4. RPC FUNCTIONS
-- =============================================

-- Function for Master Agent to create a new Agent
CREATE OR REPLACE FUNCTION public.create_agent_user(p_name text, p_email text, p_password text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  new_user_id uuid;
BEGIN
  -- Create user in auth.users
  SELECT auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' INTO new_user_id;

  -- Create profile in public.profiles
  INSERT INTO public.profiles(id, name, email, role, master_agent_id)
  VALUES(new_user_id, p_name, p_email, 'AGENT', auth.uid());
  
  RETURN 'Agent created successfully.';
EXCEPTION WHEN OTHERS THEN
  RETURN 'Error: Could not create agent. Email might be in use.';
END;
$$;

-- Function for Master Agent to create a new Master Agent
CREATE OR REPLACE FUNCTION public.create_master_agent_user(p_name text, p_email text, p_password text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  new_user_id uuid;
BEGIN
  -- Create user in auth.users
  SELECT auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' INTO new_user_id;

  -- Create profile in public.profiles
  INSERT INTO public.profiles(id, name, email, role)
  VALUES(new_user_id, p_name, p_email, 'MASTER_AGENT');
  
  RETURN 'Master Agent created successfully.';
EXCEPTION WHEN OTHERS THEN
  RETURN 'Error: Could not create master agent. Email might be in use.';
END;
$$;

-- Function for Master Agent to create a new Operator
CREATE OR REPLACE FUNCTION public.create_operator_user(p_name text, p_email text, p_password text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  new_user_id uuid;
BEGIN
  -- Create user in auth.users
  SELECT auth.admin.create_user(jsonb_build_object(
    'email', p_email,
    'password', p_password,
    'email_confirm', true,
    'user_metadata', jsonb_build_object('name', p_name)
  ))->>'id' INTO new_user_id;

  -- Create profile in public.profiles
  INSERT INTO public.profiles(id, name, email, role)
  VALUES(new_user_id, p_name, p_email, 'OPERATOR');
  
  RETURN 'Operator created successfully.';
EXCEPTION WHEN OTHERS THEN
  RETURN 'Error: Could not create operator. Email might be in use.';
END;
$$;

-- Function for Operator to add a fight to the queue
CREATE OR REPLACE FUNCTION public.add_upcoming_fight(p_red_text text, p_white_text text)
RETURNS SETOF public.upcoming_fights
LANGUAGE plpgsql
AS $$
DECLARE
    new_fight public.upcoming_fights;
BEGIN
    INSERT INTO public.upcoming_fights (participants)
    VALUES (jsonb_build_object('red', p_red_text, 'white', p_white_text))
    RETURNING * INTO new_fight;
    RETURN NEXT new_fight;
END;
$$;

-- Function for Operator to start the next fight
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    next_fight record;
BEGIN
    -- Select and lock the first upcoming fight to prevent race conditions
    SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1 FOR UPDATE;

    IF next_fight IS NOT NULL THEN
        -- Move it to the active fights table
        INSERT INTO public.fights (id, participants, status)
        VALUES (next_fight.id, next_fight.participants, 'BETTING_OPEN');

        -- Remove it from the queue
        DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
    END IF;
END;
$$;

-- Function for Operator to close betting
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id integer)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE public.fights
    SET status = 'BETTING_CLOSED'
    WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$;

-- Function for a player to place a bet
CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id integer, p_amount numeric, p_choice text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
    current_balance numeric;
    fight_status_check text;
BEGIN
    -- Check fight status
    SELECT status INTO fight_status_check FROM public.fights WHERE id = p_fight_id;
    IF fight_status_check != 'BETTING_OPEN' THEN
        RETURN 'Error: Betting is closed for this fight.';
    END IF;

    -- Check user balance
    SELECT coin_balance INTO current_balance FROM public.profiles WHERE id = auth.uid();
    IF current_balance < p_amount THEN
        RETURN 'Error: Insufficient balance.';
    END IF;

    -- Deduct amount and record bet
    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
    INSERT INTO public.bets (user_id, fight_id, amount, choice)
    VALUES (auth.uid(), p_fight_id, p_amount, p_choice::bet_choice);
    
    -- Record transaction
    INSERT INTO public.transactions (type, from_user_id, amount)
    VALUES ('BET', auth.uid(), p_amount);

    RETURN 'Bet placed successfully.';
END;
$$;

-- Function for Operator to declare a winner and distribute winnings
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id integer, p_winner_text text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    winner_choice public.fight_winner := p_winner_text::fight_winner;
    total_pool numeric;
    winner_pool numeric;
    loser_pool numeric;
    commission_rate numeric := 0.07;
    total_commission numeric;
    winning_bet record;
BEGIN
    -- Update fight status
    UPDATE public.fights SET winner = winner_choice, status = 'SETTLED', settled_at = now() WHERE id = p_fight_id;

    -- Handle DRAW or CANCELLED cases by refunding all bets
    IF winner_choice = 'DRAW' OR winner_choice = 'CANCELLED' THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('REFUND', winning_bet.user_id, winning_bet.amount);
        END LOOP;
        RETURN;
    END IF;

    -- Calculate pools for RED/WHITE win
    total_pool := (SELECT COALESCE(SUM(amount), 0) FROM public.bets WHERE fight_id = p_fight_id);
    winner_pool := (SELECT COALESCE(SUM(amount), 0) FROM public.bets WHERE fight_id = p_fight_id AND choice = winner_choice::bet_choice);
    loser_pool := total_pool - winner_pool;

    IF winner_pool > 0 THEN
        total_commission := loser_pool * commission_rate;
        UPDATE public.fights SET commission = total_commission WHERE id = p_fight_id;
        
        -- Distribute winnings to winners
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = winner_choice::bet_choice LOOP
            DECLARE
                payout_amount numeric;
                player_share numeric;
            BEGIN
                player_share := winning_bet.amount / winner_pool;
                payout_amount := winning_bet.amount + (player_share * (loser_pool - total_commission));
                UPDATE public.profiles SET coin_balance = coin_balance + payout_amount WHERE id = winning_bet.user_id;
                INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('WINNING', winning_bet.user_id, payout_amount);
            END LOOP;
        END IF;
END;
$$;


-- Function to request coins
CREATE OR REPLACE FUNCTION public.create_coin_request(p_to_user_id uuid, p_amount numeric)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO public.coin_requests (from_user_id, to_user_id, amount)
    VALUES (auth.uid(), p_to_user_id, p_amount);
END;
$$;

-- Function to respond to a coin request
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    req record;
    sender_balance numeric;
BEGIN
    SELECT * INTO req FROM public.coin_requests WHERE id = p_request_id AND to_user_id = auth.uid();
    IF req IS NULL THEN
        RETURN 'Error: Request not found or you are not authorized.';
    END IF;

    IF req.status != 'PENDING' THEN
        RETURN 'Error: This request has already been handled.';
    END IF;

    IF p_response = 'APPROVED' THEN
        SELECT coin_balance INTO sender_balance FROM public.profiles WHERE id = req.to_user_id;
        IF sender_balance < req.amount THEN
            RETURN 'Error: Insufficient funds to approve this request.';
        END IF;
        
        -- Perform the transfer
        UPDATE public.profiles SET coin_balance = coin_balance - req.amount WHERE id = req.to_user_id;
        UPDATE public.profiles SET coin_balance = coin_balance + req.amount WHERE id = req.from_user_id;
        
        -- Record transaction
        INSERT INTO public.transactions (type, from_user_id, to_user_id, amount)
        VALUES ('TRANSFER', req.to_user_id, req.from_user_id, req.amount);

        -- Update request status
        UPDATE public.coin_requests SET status = 'APPROVED' WHERE id = p_request_id;

        -- Handle adoption if necessary
        UPDATE public.profiles SET agent_id = req.to_user_id WHERE id = req.from_user_id AND agent_id IS NULL;
        UPDATE public.profiles SET master_agent_id = req.to_user_id WHERE id = req.from_user_id AND master_agent_id IS NULL AND role = 'AGENT';
        
        RETURN 'Request approved.';
    ELSE -- Declined
        UPDATE public.coin_requests SET status = 'DECLINED' WHERE id = p_request_id;
        RETURN 'Request declined.';
    END IF;
END;
$$;

-- Function to get messages between two users
CREATE OR REPLACE FUNCTION public.get_messages(p_contact_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, created_at timestamptz)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT m.id, m.sender_id, m.receiver_id, m.text, m.created_at
    FROM public.messages m
    WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_contact_id)
       OR (m.sender_id = p_contact_id AND m.receiver_id = auth.uid())
    ORDER BY m.created_at ASC;
END;
$$;

-- Function to send a message and optionally coins
CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    sender_balance numeric;
BEGIN
    -- Send coins if amount > 0
    IF p_amount > 0 THEN
        SELECT coin_balance INTO sender_balance FROM public.profiles WHERE id = auth.uid();
        IF sender_balance < p_amount THEN
            RETURN 'Error: Insufficient balance to send coins.';
        END IF;

        UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
        UPDATE public.profiles SET coin_balance = coin_balance + p_amount WHERE id = p_receiver_id;
        
        INSERT INTO public.transactions (type, from_user_id, to_user_id, amount)
        VALUES ('TRANSFER', auth.uid(), p_receiver_id, p_amount);
    END IF;

    -- Insert message
    IF p_text IS NOT NULL AND LENGTH(p_text) > 0 THEN
      INSERT INTO public.messages(sender_id, receiver_id, text)
      VALUES (auth.uid(), p_receiver_id, p_text);
    END IF;

    RETURN 'Message sent.';
END;
$$;

-- =============================================
-- 5. ROW-LEVEL SECURITY (RLS)
-- =============================================
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Policies for PROFILES table
CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Policies for FIGHTS table
CREATE POLICY "All users can view fights" ON public.fights FOR SELECT USING (true);
CREATE POLICY "Operators can update fights" ON public.fights FOR UPDATE USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');
CREATE POLICY "Operators can insert new fights (via start_next_fight)" ON public.fights FOR INSERT WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Policies for UPCOMING_FIGHTS table
CREATE POLICY "All users can view upcoming fights" ON public.upcoming_fights FOR SELECT USING (true);
CREATE POLICY "Operators can insert upcoming fights" ON public.upcoming_fights FOR INSERT WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');
CREATE POLICY "Operators can delete upcoming fights (via start_next_fight)" ON public.upcoming_fights FOR DELETE USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Policies for BETS table
CREATE POLICY "Users can view all bets" ON public.bets FOR SELECT USING (true);
CREATE POLICY "Users can insert their own bets" ON public.bets FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Policies for TRANSACTIONS table
CREATE POLICY "Users can view their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

-- Policies for COIN_REQUESTS table
CREATE POLICY "Users can view their own coin requests" ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can insert their own coin requests" ON public.coin_requests FOR INSERT WITH CHECK (auth.uid() = from_user_id);
CREATE POLICY "Users can update requests sent to them" ON public.coin_requests FOR UPDATE USING (auth.uid() = to_user_id);

-- Policies for MESSAGES table
CREATE POLICY "Users can view their own messages" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert their own messages" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- =============================================
-- 6. REAL-TIME PUBLICATION
-- =============================================
-- Ensure replica identity is set for tables with RLS
ALTER TABLE public.profiles REPLICA IDENTITY FULL;
ALTER TABLE public.fights REPLICA IDENTITY FULL;
ALTER TABLE public.upcoming_fights REPLICA IDENTITY FULL;
ALTER TABLE public.bets REPLICA IDENTITY FULL;
ALTER TABLE public.transactions REPLICA IDENTITY FULL;
ALTER TABLE public.coin_requests REPLICA IDENTITY FULL;
ALTER TABLE public.messages REPLICA IDENTITY FULL;

-- Add tables to the publication for real-time updates
DROP PUBLICATION IF EXISTS supabase_realtime;
CREATE PUBLICATION supabase_realtime;
ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
ALTER PUBLICATION supabase_realtime ADD TABLE public.fights;
ALTER PUBLICATION supabase_realtime ADD TABLE public.upcoming_fights;
ALTER PUBLICATION supabase_realtime ADD TABLE public.bets;
ALTER PUBLICATION supabase_realtime ADD TABLE public.transactions;
ALTER PUBLICATION supabase_realtime ADD TABLE public.coin_requests;
ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;