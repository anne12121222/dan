-- ------------------------------------------------------------------------------------------------
-- FINAL, RESETTABLE DATABASE SETUP SCRIPT
-- ------------------------------------------------------------------------------------------------
-- This script will completely wipe and rebuild the application schema.
-- It can be run multiple times without causing errors.
-- ------------------------------------------------------------------------------------------------

-- ------------------------------------------------------------------------------------------------
-- SECTION 1: HYPER-ROBUST RESET
-- Drop all objects in the correct dependency order to ensure a clean slate.
-- ------------------------------------------------------------------------------------------------

-- Drop the trigger from the protected auth schema first.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop all public functions.
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.create_user(text, text, text, user_role);
DROP FUNCTION IF EXISTS public.start_next_fight();
DROP FUNCTION IF EXISTS public.close_betting(bigint);
DROP FUNCTION IF EXISTS public.declare_winner(bigint, fight_winner);
DROP FUNCTION IF EXISTS public.place_bet(bigint, numeric, bet_choice);
DROP FUNCTION IF EXISTS public.create_coin_request(numeric);
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, request_status);
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric);
DROP FUNCTION IF EXISTS public.get_messages(uuid);
DROP FUNCTION IF EXISTS public.get_transactions_for_user();
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user();

-- Drop all public tables using CASCADE to also drop dependent objects like policies.
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop all custom types using CASCADE.
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;

-- ------------------------------------------------------------------------------------------------
-- SECTION 2: TYPE AND ENUM DEFINITIONS
-- ------------------------------------------------------------------------------------------------

CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- ------------------------------------------------------------------------------------------------
-- SECTION 3: TABLE CREATION
-- ------------------------------------------------------------------------------------------------

CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL,
    role public.user_role NOT NULL DEFAULT 'PLAYER',
    coin_balance numeric NOT NULL DEFAULT 0,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id),
    commission_balance numeric DEFAULT 0
);

CREATE TABLE public.fights (
    id bigserial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'SETTLED',
    winner public.fight_winner,
    commission numeric NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.upcoming_fights (
    id bigserial PRIMARY KEY,
    participants jsonb NOT NULL
);

CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id bigint NOT NULL REFERENCES public.fights(id),
    choice public.bet_choice NOT NULL,
    amount numeric NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE(user_id, fight_id)
);

CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric NOT NULL,
    type public.transaction_type NOT NULL,
    timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);

-- ------------------------------------------------------------------------------------------------
-- SECTION 4: ROW LEVEL SECURITY (RLS)
-- ------------------------------------------------------------------------------------------------

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view fights" ON public.fights FOR SELECT USING (true);

-- Add policies for other tables as needed... all public for now for simplicity.
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view upcoming fights" ON public.upcoming_fights FOR SELECT USING (true);
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view bets" ON public.bets FOR SELECT USING (true);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own messages" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own coin requests" ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);


-- ------------------------------------------------------------------------------------------------
-- SECTION 5: DATABASE FUNCTIONS & TRIGGERS
-- ------------------------------------------------------------------------------------------------

-- Function to create a profile when a new user signs up in auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, agent_id)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data ->> 'name', NEW.email), -- Use name from metadata, fallback to email
    NEW.email,
    (NEW.raw_user_meta_data ->> 'agent_id')::uuid
  );
  RETURN NEW;
END;
$$;

-- Trigger to call the function on new user creation
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- RPC to allow Master Agent to create other users (Agent or Operator)
-- THIS IS THE CRITICAL SECURITY FIX
CREATE OR REPLACE FUNCTION public.create_user(
  p_name text,
  p_email text,
  p_password text,
  p_role public.user_role
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_user_id uuid;
  current_user_id uuid := auth.uid();
  current_user_role public.user_role;
BEGIN
  -- Check if the current user is a Master Agent
  SELECT role INTO current_user_role FROM public.profiles WHERE id = current_user_id;
  IF current_user_role IS NULL OR current_user_role != 'MASTER_AGENT' THEN
    RAISE EXCEPTION 'Only Master Agents can create users.';
  END IF;

  -- Create the user in the auth schema
  new_user_id := auth.admin_create_user(p_email, p_password);

  -- Update the user's profile with the correct role and creator
  UPDATE public.profiles
  SET
    role = p_role,
    master_agent_id = CASE WHEN p_role = 'AGENT' THEN current_user_id ELSE NULL END
  WHERE id = new_user_id;

  RETURN new_user_id;
END;
$$;


-- All other RPC functions for the application to work
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void AS $$
DECLARE
    next_fight record;
BEGIN
    -- Logic to start the next fight
    SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
    IF FOUND THEN
        DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
        INSERT INTO public.fights (status) VALUES ('BETTING_OPEN');
    ELSE
        RAISE EXCEPTION 'No upcoming fights available.';
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void AS $$
BEGIN
    UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id bigint, p_winner public.fight_winner)
RETURNS void AS $$
-- Payout logic would go here
BEGIN
    UPDATE public.fights SET winner = p_winner, status = 'SETTLED' WHERE id = p_fight_id;
    -- In a real scenario, you'd calculate payouts, update balances, and create transaction logs here.
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id bigint, p_amount numeric, p_choice public.bet_choice)
RETURNS text AS $$
DECLARE
    current_balance numeric;
BEGIN
    SELECT coin_balance INTO current_balance FROM public.profiles WHERE id = auth.uid();
    IF current_balance < p_amount THEN
        RETURN 'Insufficient balance.';
    END IF;
    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
    INSERT INTO public.bets (user_id, fight_id, choice, amount) VALUES (auth.uid(), p_fight_id, p_choice, p_amount);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_coin_request(p_amount numeric)
RETURNS text AS $$
DECLARE
    superior_id uuid;
    current_user_role public.user_role;
BEGIN
    SELECT role INTO current_user_role FROM public.profiles WHERE id = auth.uid();
    IF current_user_role = 'PLAYER' THEN
        SELECT agent_id INTO superior_id FROM public.profiles WHERE id = auth.uid();
    ELSIF current_user_role = 'AGENT' THEN
        SELECT master_agent_id INTO superior_id FROM public.profiles WHERE id = auth.uid();
    ELSE
        RETURN 'Only Players and Agents can request coins.';
    END IF;
    
    IF superior_id IS NULL THEN
        RETURN 'You do not have a superior to request coins from.';
    END IF;

    INSERT INTO public.coin_requests(from_user_id, to_user_id, amount) VALUES (auth.uid(), superior_id, p_amount);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
DECLARE
    req record;
BEGIN
    SELECT * INTO req FROM public.coin_requests WHERE id = p_request_id AND to_user_id = auth.uid() AND status = 'PENDING';
    IF NOT FOUND THEN
        RETURN 'Request not found or you are not authorized.';
    END IF;
    
    UPDATE public.coin_requests SET status = p_response WHERE id = p_request_id;
    
    IF p_response = 'APPROVED' THEN
        UPDATE public.profiles SET coin_balance = coin_balance - req.amount WHERE id = auth.uid();
        UPDATE public.profiles SET coin_balance = coin_balance + req.amount WHERE id = req.from_user_id;
        INSERT INTO public.transactions(from_user_id, to_user_id, amount, type) VALUES (auth.uid(), req.from_user_id, req.amount, 'TRANSFER');
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS void AS $$
BEGIN
    IF p_amount > 0 THEN
        UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = auth.uid();
        UPDATE public.profiles SET coin_balance = coin_balance + p_amount WHERE id = p_receiver_id;
        INSERT INTO public.transactions(from_user_id, to_user_id, amount, type) VALUES (auth.uid(), p_receiver_id, p_amount, 'TRANSFER');
    END IF;

    IF p_text IS NOT NULL AND trim(p_text) != '' THEN
        INSERT INTO public.messages(sender_id, receiver_id, text) VALUES (auth.uid(), p_receiver_id, p_text);
    END IF;
END;
$$ LANGUAGE plpgsql;


-- Functions to get data respecting RLS for views
CREATE OR REPLACE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS SETOF public.messages AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.messages 
    WHERE (sender_id = auth.uid() AND receiver_id = p_other_user_id)
       OR (sender_id = p_other_user_id AND receiver_id = auth.uid())
    ORDER BY created_at ASC;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_transactions_for_user()
RETURNS SETOF public.transactions AS $$
BEGIN
    -- This would be more complex in a real app, respecting agent/MA hierarchy
    RETURN QUERY SELECT * FROM public.transactions 
    WHERE from_user_id = auth.uid() OR to_user_id = auth.uid()
    ORDER BY timestamp DESC;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_coin_requests_for_user()
RETURNS SETOF public.coin_requests AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.coin_requests 
    WHERE to_user_id = auth.uid()
    ORDER BY created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------------------------------------------------------------
-- SCRIPT COMPLETE
-- ------------------------------------------------------------------------------------------------
