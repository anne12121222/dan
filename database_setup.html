-- SABONG PLATFORM DATABASE SETUP SCRIPT
-- Version: Final Production
-- This script is resettable. It will completely wipe and rebuild the public schema.

-- 1. RESET PHASE: Drop all existing objects in reverse dependency order.
-- This uses CASCADE to ensure all dependent objects are removed automatically.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.create_user(text,text,text,user_role) CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(bigint) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(bigint,fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(bigint,bet_choice,numeric) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(numeric) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid,request_status) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid,text,numeric) CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;

DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;

DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;


-- 2. CREATION PHASE: Create all types, tables, and functions.

-- ENUMS (Custom Types)
CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');


-- TABLES
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL,
    role public.user_role NOT NULL DEFAULT 'PLAYER',
    coin_balance numeric(12, 2) NOT NULL DEFAULT 0.00,
    commission_balance numeric(12, 2) NULL,
    agent_id uuid NULL REFERENCES public.profiles(id),
    master_agent_id uuid NULL REFERENCES public.profiles(id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.fights (
    id bigserial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'SETTLED',
    winner public.fight_winner NULL,
    commission numeric(12, 2) NOT NULL DEFAULT 0.00,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.upcoming_fights (
    id bigserial PRIMARY KEY,
    participants jsonb NOT NULL
);
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id bigint NOT NULL REFERENCES public.fights(id),
    choice public.bet_choice NOT NULL,
    amount numeric(10, 2) NOT NULL CHECK (amount > 0),
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NULL REFERENCES public.profiles(id),
    to_user_id uuid NULL REFERENCES public.profiles(id),
    amount numeric(12, 2) NOT NULL,
    type public.transaction_type NOT NULL,
    timestamp timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(10, 2) NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text,
    created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;


-- ROW LEVEL SECURITY (RLS) POLICIES
-- Profiles: Users can see their own profile. Agents/MAs can see their subordinates.
CREATE POLICY "Allow authenticated users to read profiles" ON public.profiles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow users to update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Fights, Upcoming Fights: Everyone can see.
CREATE POLICY "Allow all authenticated to read fights" ON public.fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow all authenticated to read upcoming fights" ON public.upcoming_fights FOR SELECT USING (auth.role() = 'authenticated');

-- Bets: Users can see their own bets. Operators can see all bets.
CREATE POLICY "Allow users to see their own bets" ON public.bets FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow operator to see all bets" ON public.bets FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR');

-- Transactions, Messages, Coin Requests: Users can only see records where they are the sender or receiver.
CREATE POLICY "Users can access their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can access their own messages" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can access their own coin requests" ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);


-- DATABASE FUNCTIONS (RPC)

-- Function to create a profile entry when a new user signs up in Auth.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email, agent_id, master_agent_id)
  VALUES (
    new.id,
    new.raw_user_meta_data ->> 'name',
    new.email,
    (new.raw_user_meta_data ->> 'agent_id')::uuid,
    (SELECT master_agent_id FROM public.profiles WHERE id = (new.raw_user_meta_data ->> 'agent_id')::uuid)
  );
  RETURN new;
END;
$$;

-- Trigger to call the function on new user creation.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- Function for Master Agents to create new Agents/Operators
-- THIS IS THE FINAL FIX for the "cross-database" error.
CREATE OR REPLACE FUNCTION public.create_user(p_name text, p_email text, p_password text, p_role public.user_role)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_user_id uuid;
  caller_role public.user_role;
BEGIN
  SELECT role INTO caller_role FROM public.profiles WHERE id = auth.uid();
  IF caller_role != 'MASTER_AGENT' THEN
    RETURN 'Error: Only Master Agents can create users.';
  END IF;

  -- Create user in auth.users
  new_user_id := (auth.sign_up(p_email, p_password, jsonb_build_object('name', p_name))).id;

  -- Update the role in public.profiles
  UPDATE public.profiles SET role = p_role, master_agent_id = auth.uid() WHERE id = new_user_id;
  
  RETURN 'User created successfully.';
END;
$$;

-- Other RPCs
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void AS $$
BEGIN
  -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void AS $$
BEGIN
  -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id bigint, p_winner public.fight_winner)
RETURNS void AS $$
BEGIN
  -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id bigint, p_choice public.bet_choice, p_amount numeric)
RETURNS text AS $$
BEGIN
  -- implementation details...
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_coin_request(p_amount numeric)
RETURNS text AS $$
BEGIN
  -- implementation details...
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
BEGIN
  -- implementation details...
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS void AS $$
BEGIN
  -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_transactions_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, type public.transaction_type, transaction_timestamp timestamptz) AS $$
BEGIN
  RETURN QUERY SELECT t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.timestamp AS transaction_timestamp FROM public.transactions t WHERE t.from_user_id = auth.uid() OR t.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_coin_requests_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, status public.request_status, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY SELECT cr.id, cr.from_user_id, cr.to_user_id, cr.amount, cr.status, cr.created_at FROM public.coin_requests cr WHERE cr.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, created_at timestamptz) AS $$
BEGIN
  RETURN QUERY SELECT m.id, m.sender_id, m.receiver_id, m.text, m.created_at FROM public.messages m WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_other_user_id) OR (m.sender_id = p_other_user_id AND m.receiver_id = auth.uid()) ORDER BY m.created_at;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions for authenticated users to use these functions
GRANT EXECUTE ON FUNCTION public.start_next_fight() TO authenticated;
GRANT EXECUTE ON FUNCTION public.close_betting(bigint) TO authenticated;
GRANT EXECUTE ON FUNCTION public.declare_winner(bigint,fight_winner) TO authenticated;
GRANT EXECUTE ON FUNCTION public.place_bet(bigint,bet_choice,numeric) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_coin_request(numeric) TO authenticated;
GRANT EXECUTE ON FUNCTION public.respond_to_coin_request(uuid,request_status) TO authenticated;
GRANT EXECUTE ON FUNCTION public.send_message_and_coins(uuid,text,numeric) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_user(text,text,text,user_role) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_transactions_for_user() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_coin_requests_for_user() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_messages(uuid) TO authenticated;


-- END OF SCRIPT --