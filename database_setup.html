-- This script is designed to be resettable. It will drop existing objects before recreating them.

-- 1. DROP EXISTING OBJECTS (in reverse dependency order)
-- Drop functions first, as they might depend on types.
DROP FUNCTION IF EXISTS public.create_user(text, text, text, public.user_role) CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, numeric) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(numeric) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, public.request_status) CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(integer) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(integer, public.bet_choice, numeric) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(integer, public.fight_winner) CASCADE;

-- Drop tables
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;

-- Drop custom types
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;

-- 2. CREATE CUSTOM TYPES
CREATE TYPE public.user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- 3. CREATE TABLES
CREATE TABLE public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL,
    role public.user_role NOT NULL DEFAULT 'PLAYER',
    coin_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id)
);

CREATE TABLE public.fights (
    id serial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'BETTING_OPEN',
    winner public.fight_winner,
    commission numeric(15, 2) NOT NULL DEFAULT 0.00,
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.upcoming_fights (
    id serial PRIMARY KEY,
    participants jsonb NOT NULL
);

CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id integer NOT NULL REFERENCES public.fights(id),
    choice public.bet_choice NOT NULL,
    amount numeric(15, 2) NOT NULL CHECK (amount > 0),
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    type public.transaction_type NOT NULL,
    timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- 4. ENABLE ROW LEVEL SECURITY (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;

-- 5. CREATE RLS POLICIES
-- Profiles: Users can see all profiles (for names, etc.), but can only update their own.
CREATE POLICY "Allow authenticated read access" ON public.profiles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow individual update access" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Fights & Upcoming Fights: All authenticated users can view.
CREATE POLICY "Allow authenticated read access" ON public.fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow authenticated read access" ON public.upcoming_fights FOR SELECT USING (auth.role() = 'authenticated');

-- Bets, Transactions, Requests, Messages: More complex logic, handled by secure functions.
-- Generally, users can only see their own related items.
CREATE POLICY "Allow individual access" ON public.bets FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Allow related access to transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Allow related access to requests" ON public.coin_requests FOR ALL USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Allow related access to messages" ON public.messages FOR ALL USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

-- 6. SETUP AUTH TRIGGER for new user profiles
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, name, email, agent_id)
    VALUES (
        new.id,
        coalesce(new.raw_user_meta_data->>'name', split_part(new.email, '@', 1)),
        new.email,
        (new.raw_user_meta_data->>'agent_id')::uuid
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 7. CREATE RPC FUNCTIONS
-- User Management Function (HIGH SECURITY)
CREATE OR REPLACE FUNCTION public.create_user(p_name text, p_email text, p_password text, p_role public.user_role)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    new_user_id uuid;
BEGIN
    -- Check if caller is a Master Agent
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) <> 'MASTER_AGENT' THEN
        RETURN 'Error: Only Master Agents can create users.';
    END IF;

    -- Create user in auth.users
    new_user_id := (SELECT auth.sign_up(p_email, p_password));

    -- Update the role in the profiles table (created by trigger)
    UPDATE public.profiles
    SET 
        role = p_role,
        master_agent_id = CASE WHEN p_role = 'AGENT' THEN auth.uid() ELSE NULL END
    WHERE id = new_user_id;

    RETURN 'Success: User created with ID ' || new_user_id;
EXCEPTION
    WHEN others THEN
        RETURN 'Error: ' || SQLERRM;
END;
$$;

-- All other functions...
CREATE OR REPLACE FUNCTION public.get_transactions_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, type public.transaction_type, transaction_timestamp timestamptz) AS $$
BEGIN
    RETURN QUERY SELECT t.id, t.from_user_id, t.to_user_id, t.amount, t.type, t.timestamp AS transaction_timestamp FROM public.transactions t WHERE t.from_user_id = auth.uid() OR t.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_coin_requests_for_user()
RETURNS TABLE(id uuid, from_user_id uuid, to_user_id uuid, amount numeric, status public.request_status, created_at timestamptz) AS $$
BEGIN
    RETURN QUERY SELECT cr.id, cr.from_user_id, cr.to_user_id, cr.amount, cr.status, cr.created_at FROM public.coin_requests cr WHERE cr.to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS TABLE(id uuid, sender_id uuid, receiver_id uuid, text text, created_at timestamptz) AS $$
BEGIN
    RETURN QUERY SELECT m.id, m.sender_id, m.receiver_id, m.text, m.created_at FROM public.messages m WHERE (m.sender_id = auth.uid() AND m.receiver_id = p_other_user_id) OR (m.sender_id = p_other_user_id AND m.receiver_id = auth.uid()) ORDER BY m.created_at;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
RETURNS void AS $$
BEGIN
    -- implementation details...
    -- In a real app, this would handle coin transfer and message saving
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_coin_request(p_amount numeric)
RETURNS text AS $$
BEGIN
    -- implementation details...
    RETURN 'Success';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
RETURNS text AS $$
BEGIN
    -- implementation details...
    RETURN 'Success';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void AS $$
BEGIN
    -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id integer)
RETURNS void AS $$
BEGIN
    -- implementation details...
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id integer, p_choice public.bet_choice, p_amount numeric)
RETURNS text AS $$
BEGIN
    -- implementation details...
    RETURN 'Success';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id integer, p_winner public.fight_winner)
RETURNS void AS $$
BEGIN
    -- implementation details...
END;
$$ LANGUAGE plpgsql;

-- Grant usage on schema and execute on functions for authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
