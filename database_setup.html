-- Reality Boxing Federation - Database Schema & Access Control
-- Version: 2.0.0
-- Description: This script sets up the entire database schema, including tables,
--              custom types, functions for business logic, and row-level security.

--
-- SETUP PHASE 1: TYPES & ENUMS
--
-- Drop existing enums to start fresh (idempotent setup)
drop type if exists public.user_role cascade;
drop type if exists public.fight_status cascade;
drop type if exists public.transaction_type cascade;
drop type if exists public.request_status cascade;
drop type if exists public.bet_choice cascade;
drop type if exists public.fight_winner cascade;

-- Define custom enumerated types for consistency and data integrity.
create type public.user_role as enum ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
create type public.fight_status as enum ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
create type public.transaction_type as enum ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');
create type public.request_status as enum ('PENDING', 'APPROVED', 'DECLINED');
create type public.bet_choice as enum ('RED', 'WHITE');
create type public.fight_winner as enum ('RED', 'WHITE', 'DRAW', 'CANCELLED');

--
-- SETUP PHASE 2: TABLES
--
-- Profiles table to store user-specific data, extending the auth.users table.
create table if not exists public.profiles (
  id uuid not null primary key references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  name text not null,
  email text not null unique,
  role public.user_role not null,
  coin_balance numeric(15, 2) not null default 0.00,
  commission_balance numeric(15, 2) not null default 0.00,
  commission_rate numeric(5, 4) not null default 0.0700,
  transfer_fee numeric(5, 4) not null default 0.0100,
  agent_id uuid references public.profiles(id) on delete set null,
  master_agent_id uuid references public.profiles(id) on delete set null
);
comment on table public.profiles is 'Stores all user profile information.';

-- Other tables with cascading deletes and orphan prevention.
create table if not exists public.fights (
  id serial primary key,
  created_at timestamptz not null default now(),
  status public.fight_status not null,
  winner public.fight_winner,
  commission numeric(15, 2) not null default 0.00
);
create table if not exists public.upcoming_fights (
  id serial primary key,
  participants jsonb not null
);
create table if not exists public.bets (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  fight_id integer not null references public.fights(id) on delete cascade,
  amount numeric(15, 2) not null,
  choice public.bet_choice not null,
  created_at timestamptz not null default now()
);
create table if not exists public.transactions (
  id uuid primary key default gen_random_uuid(),
  from_user_id uuid references public.profiles(id) on delete set null,
  to_user_id uuid references public.profiles(id) on delete set null,
  amount numeric(15, 2) not null,
  type public.transaction_type not null,
  transaction_timestamp timestamptz not null default now()
);
create table if not exists public.coin_requests (
  id uuid primary key default gen_random_uuid(),
  from_user_id uuid not null references public.profiles(id) on delete cascade,
  to_user_id uuid not null references public.profiles(id) on delete cascade,
  amount numeric(15, 2) not null,
  status public.request_status not null default 'PENDING',
  created_at timestamptz not null default now()
);
create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  sender_id uuid not null references public.profiles(id) on delete cascade,
  receiver_id uuid not null references public.profiles(id) on delete cascade,
  text text not null,
  amount numeric(15, 2),
  created_at timestamptz not null default now()
);

--
-- SETUP PHASE 3: USER PROFILE MANAGEMENT (TRIGGERS)
--
-- This function handles new user creation and profile setup.
create or replace function public.handle_new_user()
returns trigger as $$
declare
  user_name text;
begin
  -- Use name from metadata if available, otherwise derive from email.
  user_name := coalesce(new.raw_user_meta_data->>'name', split_part(new.email, '@', 1));

  insert into public.profiles (id, name, email, role)
  values (new.id, user_name, new.email, 'PLAYER'::public.user_role);
  return new;
end;
$$ language plpgsql security definer set search_path = '';

-- Drop existing trigger to ensure a clean setup.
drop trigger if exists on_auth_user_created on auth.users;
-- Create the trigger that fires after a new user signs up.
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

--
-- SETUP PHASE 4: ROW-LEVEL SECURITY (RLS)
--
-- Enable RLS for all relevant tables.
alter table public.profiles enable row level security;
alter table public.bets enable row level security;
alter table public.transactions enable row level security;
alter table public.coin_requests enable row level security;
alter table public.messages enable row level security;
alter table public.fights enable row level security;
alter table public.upcoming_fights enable row level security;

-- Drop existing policies for idempotency.
drop policy if exists "Allow service_role full access" on public.profiles;
drop policy if exists "Allow users to view their own profile" on public.profiles;
drop policy if exists "Allow users to update their own profile" on public.profiles;
drop policy if exists "Allow users to place their own bets" on public.bets;
drop policy if exists "Allow users to view their own bets" on public.bets;
drop policy if exists "Allow superiors to view subordinate bets" on public.bets;
drop policy if exists "Allow users to view their own transactions" on public.transactions;
drop policy if exists "Allow users to manage their own coin requests" on public.coin_requests;
drop policy if exists "Allow recipients to update coin requests" on public.coin_requests;
drop policy if exists "Allow users to manage their own messages" on public.messages;
drop policy if exists "Allow public read access to fights" on public.fights;
drop policy if exists "Allow public read access to upcoming_fights" on public.upcoming_fights;

-- Create Policies
-- Profiles: Users can see/update their own profile. Service role has full access for triggers.
create policy "Allow service_role full access" on public.profiles for all to service_role using (true);
create policy "Allow users to view their own profile" on public.profiles for select using (auth.uid() = id);
create policy "Allow users to update their own profile" on public.profiles for update using (auth.uid() = id);
-- Bets: Users can manage their own bets. Superiors can see their subordinates' bets.
create policy "Allow users to place their own bets" on public.bets for insert with check (auth.uid() = user_id);
create policy "Allow users to view their own bets" on public.bets for select using (auth.uid() = user_id);
-- Transactions: Users can see their own transactions.
create policy "Allow users to view their own transactions" on public.transactions for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);
-- Coin Requests: Users can create/see their own requests. Recipients can see and update them.
create policy "Allow users to manage their own coin requests" on public.coin_requests for all using (auth.uid() = from_user_id or auth.uid() = to_user_id);
-- Messages: Users can create/see their own messages.
create policy "Allow users to manage their own messages" on public.messages for all using (auth.uid() = sender_id or auth.uid() = receiver_id);
-- Fights and Upcoming Fights: Publicly readable.
create policy "Allow public read access to fights" on public.fights for select using (true);
create policy "Allow public read access to upcoming_fights" on public.upcoming_fights for select using (true);

--
-- SETUP PHASE 5: STORED PROCEDURES & FUNCTIONS (RPC)
--
-- Drop functions before recreating them to handle signature changes
drop function if exists public.get_user_view_data();
drop function if exists public.get_all_users_for_operator();
drop function if exists public.respond_to_coin_request(uuid, public.request_status);

-- Get User View Data: Returns all users a specific user is allowed to see.
create or replace function public.get_user_view_data()
returns table (
    id uuid, name text, email text, role public.user_role,
    coin_balance numeric, commission_balance numeric,
    commission_rate numeric, transfer_fee numeric,
    agent_id uuid, master_agent_id uuid
) as $$
declare
    current_user_id uuid := auth.uid();
    current_user_profile public.profiles;
begin
    select * into current_user_profile from public.profiles where profiles.id = current_user_id;

    -- Always return the current user
    return query select p.* from public.profiles p where p.id = current_user_id;

    -- Return other users based on role and status
    if current_user_profile.role = 'PLAYER'::public.user_role then
        if current_user_profile.agent_id is null then
            -- Unassigned player sees all agents
            return query select * from public.profiles where profiles.role = 'AGENT'::public.user_role;
        else
            -- Assigned player sees their agent
            return query select * from public.profiles where profiles.id = current_user_profile.agent_id;
        end if;
    elsif current_user_profile.role = 'AGENT'::public.user_role then
        if current_user_profile.master_agent_id is null then
            -- Unassigned agent sees all master agents
            return query select * from public.profiles where profiles.role = 'MASTER_AGENT'::public.user_role;
        else
            -- Assigned agent sees their master agent
            return query select * from public.profiles where profiles.id = current_user_profile.master_agent_id;
        end if;
        -- An agent always sees their players
        return query select * from public.profiles where profiles.agent_id = current_user_id;
    elsif current_user_profile.role = 'MASTER_AGENT'::public.user_role then
        -- A master agent sees their agents
        return query select * from public.profiles where profiles.master_agent_id = current_user_id;
    end if;

end;
$$ language plpgsql stable security definer set search_path = '';

-- Function for Operator to get all users
create or replace function public.get_all_users_for_operator()
returns setof public.profiles as $$
declare
  caller_role public.user_role;
begin
  -- Securely get the caller's role. RLS permits this as it's their own row.
  select role into caller_role from public.profiles where id = auth.uid();

  -- Enforce authorization
  if caller_role != 'OPERATOR'::public.user_role then
    raise exception 'Unauthorized: Only operators can access all user data.';
  end if;

  -- If authorized, return all profiles. This part bypasses RLS because the function is a SECURITY DEFINER.
  return query select * from public.profiles;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Internal helper functions for secure coin transfers and assignments
create or replace function public.internal_transfer_coins(p_from_id uuid, p_to_id uuid, p_amount numeric)
returns void as $$
begin
  update public.profiles set coin_balance = coin_balance - p_amount where id = p_from_id;
  update public.profiles set coin_balance = coin_balance + p_amount where id = p_to_id;
end;
$$ language plpgsql security definer set search_path = '';

create or replace function public.internal_set_player_agent(p_player_id uuid, p_agent_id uuid)
returns void as $$
begin
  update public.profiles set agent_id = p_agent_id where id = p_player_id;
end;
$$ language plpgsql security definer set search_path = '';


-- Respond to Coin Request (with deadlock prevention)
create or replace function public.respond_to_coin_request(p_request_id uuid, p_response public.request_status)
returns text as $$
declare
  coin_req public.coin_requests;
  sender_profile public.profiles;
  receiver_profile public.profiles;
  first_user_id uuid;
  second_user_id uuid;
begin
  if p_response not in ('APPROVED', 'DECLINED') then
    return 'Error: Invalid response.';
  end if;

  -- Lock the request row to prevent concurrent modifications
  select * into coin_req from public.coin_requests where id = p_request_id for update;

  if not found then return 'Error: Request not found.'; end if;
  if coin_req.status != 'PENDING' then return 'Error: Request already actioned.'; end if;
  if coin_req.to_user_id != auth.uid() then return 'Error: You are not authorized to respond to this request.'; end if;

  -- Lock user profiles in a deterministic order to prevent deadlocks
  if coin_req.from_user_id < coin_req.to_user_id then
      first_user_id := coin_req.from_user_id;
      second_user_id := coin_req.to_user_id;
  else
      first_user_id := coin_req.to_user_id;
      second_user_id := coin_req.from_user_id;
  end if;

  select * into sender_profile from public.profiles where id = first_user_id for update;
  select * into receiver_profile from public.profiles where id = second_user_id for update;
  
  -- Re-fetch profiles in correct variables after locking
  select * into sender_profile from public.profiles where id = coin_req.from_user_id;
  select * into receiver_profile from public.profiles where id = coin_req.to_user_id;

  if p_response = 'APPROVED' then
    if receiver_profile.coin_balance < coin_req.amount then return 'Error: Insufficient funds to approve request.'; end if;

    -- Perform the transfer
    perform internal_transfer_coins(receiver_profile.id, sender_profile.id, coin_req.amount);
    insert into public.transactions (from_user_id, to_user_id, amount, type)
    values (receiver_profile.id, sender_profile.id, coin_req.amount, 'TRANSFER');

    -- Adoption logic: if sender is an unassigned player/agent, assign them to the approver.
    if sender_profile.role = 'PLAYER'::public.user_role and sender_profile.agent_id is null and receiver_profile.role = 'AGENT'::public.user_role then
      perform internal_set_player_agent(sender_profile.id, receiver_profile.id);
    elsif sender_profile.role = 'AGENT'::public.user_role and sender_profile.master_agent_id is null and receiver_profile.role = 'MASTER_AGENT'::public.user_role then
       update public.profiles set master_agent_id = receiver_profile.id where id = sender_profile.id;
    end if;
  end if;

  update public.coin_requests set status = p_response where id = p_request_id;
  return 'Success: Request has been ' || lower(p_response::text) || '.';
end;
$$ language plpgsql security definer;

-- Other RPC functions
create or replace function public.create_coin_request(p_amount numeric, p_target_user_id uuid default null)
returns text as $$
begin
  insert into public.coin_requests (from_user_id, to_user_id, amount)
  values (auth.uid(), p_target_user_id, p_amount);
  return 'Coin request sent successfully.';
end;
$$ language plpgsql;

create or replace function public.place_bet(p_fight_id int, p_amount numeric, p_choice public.bet_choice)
returns text as $$
begin
  -- Placeholder for full implementation
  return null;
end;
$$ language plpgsql;

create or replace function public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount numeric)
returns text as $$
begin
  -- Placeholder for full implementation
  return null;
end;
$$ language plpgsql;

-- Stubs for Operator functions
create or replace function public.start_next_fight() returns void as $$ begin end; $$ language plpgsql;
create or replace function public.close_betting(p_fight_id int) returns void as $$ begin end; $$ language plpgsql;
create or replace function public.declare_winner(p_fight_id int, p_winner_text text) returns void as $$ begin end; $$ language plpgsql;
create or replace function public.add_upcoming_fight(p_red text, p_white text) returns void as $$ begin end; $$ language plpgsql;

-- Data fetching functions for the app
drop function if exists public.get_coin_requests_for_user();
create or replace function public.get_coin_requests_for_user()
returns setof public.coin_requests as $$
  select * from public.coin_requests where from_user_id = auth.uid() or to_user_id = auth.uid();
$$ language sql stable security invoker;

drop function if exists public.get_transactions_for_user();
create or replace function public.get_transactions_for_user()
returns setof public.transactions as $$
  select * from public.transactions where from_user_id = auth.uid() or to_user_id = auth.uid();
$$ language sql stable security invoker;

drop function if exists public.get_messages(uuid);
create or replace function public.get_messages(p_other_user_id uuid)
returns setof public.messages as $$
  select * from public.messages 
  where (sender_id = auth.uid() and receiver_id = p_other_user_id) or (sender_id = p_other_user_id and receiver_id = auth.uid())
  order by created_at asc;
$$ language sql stable security invoker;


-- END OF SCRIPT --