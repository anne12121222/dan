-- RESET SCRIPT: Safely drop all existing objects before creating new ones.
-- This script is now idempotent and can be run multiple times without errors.

-- Explicitly drop all functions with CASCADE to handle dependencies.
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.create_user(text, text, text, user_role) CASCADE;
DROP FUNCTION IF EXISTS public.start_next_fight() CASCADE;
DROP FUNCTION IF EXISTS public.close_betting(integer) CASCADE;
DROP FUNCTION IF EXISTS public.declare_winner(integer, fight_winner) CASCADE;
DROP FUNCTION IF EXISTS public.place_bet(integer, integer, bet_choice) CASCADE;
DROP FUNCTION IF EXISTS public.create_coin_request(integer) CASCADE;
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, request_status) CASCADE;
DROP FUNCTION IF EXISTS public.get_transactions_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_coin_requests_for_user() CASCADE;
DROP FUNCTION IF EXISTS public.get_messages(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.send_message_and_coins(uuid, text, integer) CASCADE;

-- Drop all tables with CASCADE.
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop all custom types with CASCADE. This is a final catch-all.
DROP TYPE IF EXISTS public.request_status CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.user_role CASCADE;


-- SETUP SCRIPT
-- 1. ENUMS (TYPES)
CREATE TYPE user_role AS ENUM ('OPERATOR', 'MASTER_AGENT', 'AGENT', 'PLAYER');
CREATE TYPE fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE transaction_type AS ENUM ('TRANSFER', 'COMMISSION', 'MINT', 'BET_WIN', 'BET_PLACE', 'BET_REFUND');
CREATE TYPE request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- 2. TABLES
-- User Profiles Table
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    role user_role NOT NULL DEFAULT 'PLAYER',
    coin_balance numeric NOT NULL DEFAULT 0,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id),
    commission_balance numeric DEFAULT 0
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Fights Table
CREATE TABLE public.fights (
    id serial PRIMARY KEY,
    status fight_status NOT NULL DEFAULT 'SETTLED',
    winner fight_winner,
    commission numeric NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Upcoming Fights Table
CREATE TABLE public.upcoming_fights (
    id serial PRIMARY KEY,
    participants jsonb NOT NULL
);

-- Bets Table
CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id integer NOT NULL REFERENCES public.fights(id),
    choice bet_choice NOT NULL,
    amount numeric NOT NULL CHECK (amount > 0),
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Coin Requests Table
CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric NOT NULL CHECK (amount > 0),
    status request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Transactions Table
CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid REFERENCES public.profiles(id), -- NULL for minting
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric NOT NULL,
    type transaction_type NOT NULL,
    timestamp timestamptz NOT NULL DEFAULT now()
);

-- Messages Table
CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- 3. ROW LEVEL SECURITY
CREATE POLICY "Enable read access for all users" ON "public"."profiles" FOR SELECT USING (true);
CREATE POLICY "Enable update for users based on user_id" ON "public"."profiles" FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Enable insert for authenticated users only" ON "public"."profiles" FOR INSERT WITH CHECK (auth.uid() = id);
-- Add RLS for other tables as needed for production security

-- 4. DATABASE FUNCTIONS (RPC)

-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  _agent_id uuid;
  _name text;
BEGIN
  -- Handle manual user creation from Supabase dashboard where raw_user_meta_data is empty.
  -- Use the part of the email before the '@' as a default name if one isn't provided.
  _name := COALESCE(
    new.raw_user_meta_data->>'name',
    SPLIT_PART(new.email, '@', 1)
  );
  
  -- agent_id will be null if not provided, which is correct for manual creation.
  _agent_id := (new.raw_user_meta_data->>'agent_id')::uuid;

  INSERT INTO public.profiles (id, name, email, agent_id, master_agent_id)
  VALUES (
    new.id,
    _name, -- Use the safe name variable
    new.email,
    _agent_id,
    (SELECT p.master_agent_id FROM public.profiles p WHERE p.id = _agent_id)
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function when a new user signs up
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Function for Master Agent to create other users (FIXED with SECURITY DEFINER)
CREATE OR REPLACE FUNCTION public.create_user(p_name text, p_email text, p_password text, p_role user_role)
RETURNS text AS $$
DECLARE
  new_user_id uuid;
  current_user_role user_role;
  current_user_id uuid := auth.uid();
BEGIN
  SELECT role INTO current_user_role FROM public.profiles WHERE id = current_user_id;
  IF current_user_role != 'MASTER_AGENT' THEN
    RETURN 'Error: Only Master Agents can create users.';
  END IF;

  -- Use the auth.admin.createUser function for security
  new_user_id := (SELECT auth.admin.create_user(p_email, p_password, json_build_object('name', p_name))).id;

  INSERT INTO public.profiles (id, name, email, role, master_agent_id)
  VALUES (new_user_id, p_name, p_email, p_role, CASE WHEN p_role = 'AGENT' THEN current_user_id ELSE NULL END);

  RETURN 'Success';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Function for Operator to start the next fight
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void AS $$
DECLARE
    next_fight RECORD;
BEGIN
    SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No upcoming fights scheduled.';
    END IF;

    INSERT INTO public.fights (status) VALUES ('BETTING_OPEN');
    DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
END;
$$ LANGUAGE plpgsql;

-- Function for Operator to close betting
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id integer)
RETURNS void AS $$
BEGIN
    UPDATE public.fights SET status = 'BETTING_CLOSED' WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql;


-- Function for Operator to declare a winner
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id integer, p_winner fight_winner)
RETURNS void AS $$
DECLARE
    bet_record RECORD;
    total_red_bets numeric;
    total_white_bets numeric;
    total_pool numeric;
    winner_pool numeric;
    loser_pool numeric;
    commission_rate numeric := 0.10; -- 10% commission
    total_commission numeric;
    payout_rate numeric;
    player_record RECORD;
BEGIN
    -- Update fight status
    UPDATE public.fights SET winner = p_winner, status = 'SETTLED' WHERE id = p_fight_id;

    -- Handle Draw or Cancelled
    IF p_winner = 'DRAW' OR p_winner = 'CANCELLED' THEN
        FOR bet_record IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + bet_record.amount WHERE id = bet_record.user_id;
            INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, bet_record.user_id, bet_record.amount, 'BET_REFUND');
        END LOOP;
        RETURN;
    END IF;

    -- Calculate pools
    SELECT COALESCE(SUM(amount), 0) INTO total_red_bets FROM public.bets WHERE fight_id = p_fight_id AND choice = 'RED';
    SELECT COALESCE(SUM(amount), 0) INTO total_white_bets FROM public.bets WHERE fight_id = p_fight_id AND choice = 'WHITE';
    total_pool := total_red_bets + total_white_bets;

    IF p_winner = 'RED' THEN
        winner_pool := total_red_bets;
        loser_pool := total_white_bets;
    ELSE -- WHITE wins
        winner_pool := total_white_bets;
        loser_pool := total_red_bets;
    END IF;

    -- Calculate commission
    total_commission := loser_pool * commission_rate;
    UPDATE public.fights SET commission = total_commission WHERE id = p_fight_id;

    -- Distribute commission to MA and System (example: 50/50 split)
    UPDATE public.profiles SET commission_balance = commission_balance + (total_commission / 2) WHERE role = 'MASTER_AGENT';

    -- Calculate payout
    IF winner_pool > 0 THEN
        payout_rate := (total_pool - total_commission) / winner_pool;
    ELSE
        payout_rate := 0;
    END IF;

    -- Distribute winnings
    FOR bet_record IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice = p_winner LOOP
        SELECT * INTO player_record FROM public.profiles WHERE id = bet_record.user_id;
        
        UPDATE public.profiles SET coin_balance = coin_balance + (bet_record.amount * payout_rate) WHERE id = bet_record.user_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (NULL, bet_record.user_id, (bet_record.amount * payout_rate), 'BET_WIN');
    END LOOP;
END;
$$ LANGUAGE plpgsql;


-- Function for Player to place a bet
CREATE OR REPLACE FUNCTION public.place_bet(p_fight_id integer, p_amount integer, p_choice bet_choice)
RETURNS text AS $$
DECLARE
    current_balance numeric;
    player_id uuid := auth.uid();
BEGIN
    SELECT coin_balance INTO current_balance FROM public.profiles WHERE id = player_id;
    IF current_balance < p_amount THEN
        RETURN 'Error: Insufficient balance.';
    END IF;

    UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = player_id;
    INSERT INTO public.bets(user_id, fight_id, amount, choice) VALUES (player_id, p_fight_id, p_amount, p_choice);
    INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (player_id, NULL, p_amount, 'BET_PLACE');
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;


-- Function to create a coin request
CREATE OR REPLACE FUNCTION public.create_coin_request(p_amount integer)
RETURNS text AS $$
DECLARE
    requester_id uuid := auth.uid();
    recipient_id uuid;
    requester_role user_role;
BEGIN
    SELECT role, agent_id, master_agent_id INTO requester_role, recipient_id, recipient_id FROM public.profiles WHERE id = requester_id;
    
    IF requester_role = 'PLAYER' THEN
        SELECT agent_id INTO recipient_id FROM public.profiles WHERE id = requester_id;
    ELSIF requester_role = 'AGENT' THEN
        SELECT master_agent_id INTO recipient_id FROM public.profiles WHERE id = requester_id;
    ELSE
        RETURN 'Error: Only Players and Agents can request coins.';
    END IF;

    IF recipient_id IS NULL THEN
        RETURN 'Error: Cannot find a recipient for the request.';
    END IF;

    INSERT INTO public.coin_requests (from_user_id, to_user_id, amount) VALUES (requester_id, recipient_id, p_amount);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to respond to a coin request
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response request_status)
RETURNS text AS $$
DECLARE
    request RECORD;
    responder_id uuid := auth.uid();
    responder_balance numeric;
BEGIN
    SELECT * INTO request FROM public.coin_requests WHERE id = p_request_id;
    
    IF request.to_user_id != responder_id THEN
        RETURN 'Error: You are not authorized to respond to this request.';
    END IF;

    IF request.status != 'PENDING' THEN
        RETURN 'Error: This request has already been processed.';
    END IF;

    IF p_response = 'APPROVED' THEN
        SELECT coin_balance INTO responder_balance FROM public.profiles WHERE id = responder_id;
        IF responder_balance < request.amount THEN
            RETURN 'Error: Insufficient balance to approve this request.';
        END IF;

        UPDATE public.profiles SET coin_balance = coin_balance - request.amount WHERE id = responder_id;
        UPDATE public.profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (responder_id, request.from_user_id, request.amount, 'TRANSFER');
    END IF;

    UPDATE public.coin_requests SET status = p_response WHERE id = p_request_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;


-- Functions to get data for specific user roles
CREATE OR REPLACE FUNCTION public.get_transactions_for_user()
RETURNS SETOF transactions AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.transactions WHERE from_user_id = auth.uid() OR to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_coin_requests_for_user()
RETURNS SETOF coin_requests AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.coin_requests WHERE to_user_id = auth.uid();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_messages(p_other_user_id uuid)
RETURNS SETOF messages AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.messages 
    WHERE (sender_id = auth.uid() AND receiver_id = p_other_user_id)
       OR (sender_id = p_other_user_id AND receiver_id = auth.uid())
    ORDER BY created_at ASC;
END;
$$ LANGUAGE plpgsql;

-- Function to send message and coins
CREATE OR REPLACE FUNCTION public.send_message_and_coins(p_receiver_id uuid, p_text text, p_amount integer)
RETURNS void AS $$
DECLARE
    sender_id uuid := auth.uid();
    sender_balance numeric;
BEGIN
    IF p_amount > 0 THEN
        SELECT coin_balance INTO sender_balance FROM public.profiles WHERE id = sender_id;
        IF sender_balance < p_amount THEN
            RAISE EXCEPTION 'Insufficient balance to send coins.';
        END IF;

        UPDATE public.profiles SET coin_balance = coin_balance - p_amount WHERE id = sender_id;
        UPDATE public.profiles SET coin_balance = coin_balance + p_amount WHERE id = p_receiver_id;
        INSERT INTO public.transactions (from_user_id, to_user_id, amount, type) VALUES (sender_id, p_receiver_id, p_amount, 'TRANSFER');
    END IF;

    IF p_text IS NOT NULL AND TRIM(p_text) != '' THEN
        INSERT INTO public.messages(sender_id, receiver_id, text) VALUES (sender_id, p_receiver_id, p_text);
    END IF;
END;
$$ LANGUAGE plpgsql;