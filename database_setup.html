-- =================================================================================================
-- Reality Boxing - Betting Platform Schema & Access-Control Logic
-- =================================================================================================
-- To run this script:
-- 1. Navigate to the SQL Editor in your Supabase project dashboard.
-- 2. Create a new query.
-- 3. Copy the entire content of this file.
-- 4. Paste it into the query editor.
-- 5. Click "Run".
--
-- This script is idempotent, meaning it can be run multiple times safely.
-- It will clean up the old schema before setting up the new one.
-- =================================================================================================


-- =================================================================================================
-- 0. INITIAL CLEANUP
-- =================================================================================================
-- Drop existing policies, triggers, functions, tables, and types in a safe order to avoid dependency errors.

-- Disable Row Level Security on all tables to allow dropping policies
DO $$
DECLARE
    table_record RECORD;
BEGIN
    FOR table_record IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(table_record.tablename) || ' DISABLE ROW LEVEL SECURITY;';
    END LOOP;
END $$;

-- Drop all existing policies
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    FOR policy_record IN (SELECT policyname, tablename FROM pg_policies WHERE schemaname = 'public') LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_record.policyname) || ' ON public.' || quote_ident(policy_record.tablename) || ';';
    END LOOP;
END $$;

-- Drop the user creation trigger from auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop all functions
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.handle_new_player(text, text, text, uuid);
DROP FUNCTION IF EXISTS public.create_user_by_master_agent(text, text, text, public.user_role, uuid);
DROP FUNCTION IF EXISTS public.start_next_fight();
DROP FUNCTION IF EXISTS public.close_betting(bigint);
DROP FUNCTION IF EXISTS public.declare_winner(bigint, public.fight_winner);
DROP FUNCTION IF EXISTS public.respond_to_coin_request(uuid, text);
DROP FUNCTION IF EXISTS public.send_message(uuid, text, numeric);
DROP FUNCTION IF EXISTS public.get_player_fight_history(uuid);
DROP FUNCTION IF EXISTS public.get_user_transactions(uuid);
DROP FUNCTION IF EXISTS public.get_agent_requests_for_master(uuid);
DROP FUNCTION IF EXISTS public.get_messages(uuid, uuid);

-- Drop all tables
DROP TABLE IF EXISTS public.bets CASCADE;
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.coin_requests CASCADE;
DROP TABLE IF EXISTS public.fights CASCADE;
DROP TABLE IF EXISTS public.upcoming_fights CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop all custom types (enums)
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.fight_status CASCADE;
DROP TYPE IF EXISTS public.bet_choice CASCADE;
DROP TYPE IF EXISTS public.fight_winner CASCADE;
DROP TYPE IF EXISTS public.transaction_type CASCADE;
DROP TYPE IF EXISTS public.request_status CASCADE;


-- =================================================================================================
-- 1. ENUMERATIONS (CUSTOM DATA TYPES)
-- =================================================================================================
CREATE TYPE public.user_role AS ENUM ('PLAYER', 'AGENT', 'MASTER_AGENT', 'OPERATOR');
CREATE TYPE public.fight_status AS ENUM ('BETTING_OPEN', 'BETTING_CLOSED', 'SETTLED');
CREATE TYPE public.bet_choice AS ENUM ('RED', 'WHITE');
CREATE TYPE public.fight_winner AS ENUM ('RED', 'WHITE', 'DRAW', 'CANCELLED');
CREATE TYPE public.transaction_type AS ENUM ('MINT', 'TRANSFER', 'COMMISSION', 'BET', 'WINNING', 'REFUND');
CREATE TYPE public.request_status AS ENUM ('PENDING', 'APPROVED', 'DECLINED');

-- =================================================================================================
-- 2. TABLES
-- =================================================================================================

-- Profiles Table: Stores public user data and application-specific info.
CREATE TABLE public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    role public.user_role NOT NULL DEFAULT 'PLAYER',
    coin_balance numeric(15, 2) NOT NULL DEFAULT 1000.00,
    commission_balance numeric(15, 2) NOT NULL DEFAULT 0.00,
    agent_id uuid REFERENCES public.profiles(id),
    master_agent_id uuid REFERENCES public.profiles(id),
    commission_rate numeric(4, 2) NOT NULL DEFAULT 0.07,
    transfer_fee numeric(4, 2) NOT NULL DEFAULT 0.01
);
COMMENT ON TABLE public.profiles IS 'Stores all user profile data.';

-- Fights Table: Stores the state of current and past fights.
CREATE TABLE public.fights (
    id bigserial PRIMARY KEY,
    status public.fight_status NOT NULL DEFAULT 'BETTING_OPEN',
    winner public.fight_winner,
    betting_ends_at timestamptz,
    commission numeric(15, 2),
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.fights IS 'Represents the state of each fight.';

-- Upcoming Fights Table: A queue for fights scheduled by the operator.
CREATE TABLE public.upcoming_fights (
    id bigserial PRIMARY KEY,
    red_participant text NOT NULL,
    white_participant text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.upcoming_fights IS 'Queue for upcoming fights.';

-- Bets Table: Stores all bets placed by players on fights.
CREATE TABLE public.bets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    fight_id bigint NOT NULL REFERENCES public.fights(id),
    amount numeric(15, 2) NOT NULL CHECK (amount > 0),
    choice public.bet_choice NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.bets IS 'Stores player bets on fights.';

-- Transactions Table: A ledger of all coin movements.
CREATE TABLE public.transactions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    type public.transaction_type NOT NULL,
    from_user_id uuid REFERENCES public.profiles(id),
    to_user_id uuid REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL,
    transaction_timestamp timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.transactions IS 'Ledger of all coin movements.';

-- Coin Requests Table: Manages coin requests between users.
CREATE TABLE public.coin_requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    from_user_id uuid NOT NULL REFERENCES public.profiles(id),
    to_user_id uuid NOT NULL REFERENCES public.profiles(id),
    amount numeric(15, 2) NOT NULL CHECK (amount > 0),
    status public.request_status NOT NULL DEFAULT 'PENDING',
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.coin_requests IS 'Manages coin requests between users.';

-- Messages Table: Stores chat messages between users.
CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    text text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.messages IS 'Stores chat messages between users.';

-- =================================================================================================
-- 3. TRIGGERS & FUNCTIONS
-- =================================================================================================

-- Function to create a profile for a new user.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
    INSERT INTO public.profiles (id, name, email, role, agent_id)
    VALUES (
        new.id,
        COALESCE(new.raw_user_meta_data->>'name', new.email), -- Use email as name if not provided
        new.email,
        COALESCE((new.raw_user_meta_data->>'role')::public.user_role, 'PLAYER'::public.user_role), -- Default role to PLAYER if not provided
        (new.raw_user_meta_data->>'agent_id')::uuid
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
COMMENT ON FUNCTION public.handle_new_user IS 'Creates a profile when a new user signs up in auth.users.';

-- Trigger to call handle_new_user on new user creation.
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =================================================================================================
-- 4. RPC FUNCTIONS (for client-side calls)
-- =================================================================================================

-- Function for new player registration
CREATE OR REPLACE FUNCTION public.handle_new_player(name text, email text, password text, agent_id uuid)
RETURNS text AS $$
DECLARE
    new_user_id uuid;
BEGIN
    -- Create the user in the auth schema
    new_user_id := auth.admin_create_user(email, password, jsonb_build_object(
        'name', name,
        'role', 'PLAYER',
        'agent_id', agent_id
    ));
    RETURN 'Player account created successfully.';
EXCEPTION WHEN OTHERS THEN
    RETURN 'Error: Could not create player. ' || SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function for Master Agent to create other users
CREATE OR REPLACE FUNCTION public.create_user_by_master_agent(
    name text,
    email text,
    password text,
    role public.user_role,
    master_agent_id uuid
)
RETURNS text AS $$
DECLARE
    new_user_id uuid;
    creating_user_role public.user_role;
BEGIN
    -- Ensure the user calling this function is a Master Agent
    SELECT p.role INTO creating_user_role FROM public.profiles p WHERE p.id = auth.uid();
    IF creating_user_role IS NULL OR creating_user_role != 'MASTER_AGENT' THEN
        RETURN 'Error: Permission denied. Only Master Agents can create users.';
    END IF;

    -- Create the user in the auth schema
    new_user_id := auth.admin_create_user(email, password, jsonb_build_object(
        'name', name,
        'role', role
    ));

    -- If creating an Agent, assign the master_agent_id
    IF role = 'AGENT' THEN
        UPDATE public.profiles SET master_agent_id = master_agent_id WHERE id = new_user_id;
    END IF;
    
    RETURN role || ' account created successfully.';
EXCEPTION WHEN OTHERS THEN
    RETURN 'Error: Could not create user. ' || SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function for Operator to start the next fight
CREATE OR REPLACE FUNCTION public.start_next_fight()
RETURNS void AS $$
DECLARE
    next_fight record;
BEGIN
    -- Check if the caller is an Operator
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
        RAISE EXCEPTION 'Only operators can start a fight.';
    END IF;

    -- Get the next fight from the queue
    SELECT * INTO next_fight FROM public.upcoming_fights ORDER BY id ASC LIMIT 1;
    IF next_fight IS NULL THEN
        RAISE EXCEPTION 'No upcoming fights in the queue.';
    END IF;

    -- Create a new active fight
    INSERT INTO public.fights (status, betting_ends_at)
    VALUES ('BETTING_OPEN', now() + interval '60 seconds');

    -- Remove the fight from the queue
    DELETE FROM public.upcoming_fights WHERE id = next_fight.id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function for Operator to close betting
CREATE OR REPLACE FUNCTION public.close_betting(p_fight_id bigint)
RETURNS void AS $$
BEGIN
    -- Check if the caller is an Operator
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
        RAISE EXCEPTION 'Only operators can close betting.';
    END IF;

    UPDATE public.fights
    SET status = 'BETTING_CLOSED'
    WHERE id = p_fight_id AND status = 'BETTING_OPEN';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function for Operator to declare a winner and settle bets
CREATE OR REPLACE FUNCTION public.declare_winner(p_fight_id bigint, p_winner public.fight_winner)
RETURNS void AS $$
DECLARE
    fight_commission_rate numeric := 0.10; -- 10% commission
    total_pool numeric;
    winner_pool numeric;
    loser_pool numeric;
    total_commission numeric;
    winning_bet record;
BEGIN
    -- Check if the caller is an Operator
    IF (SELECT role FROM public.profiles WHERE id = auth.uid()) != 'OPERATOR' THEN
        RAISE EXCEPTION 'Only operators can declare winners.';
    END IF;

    -- Update fight status
    UPDATE public.fights SET status = 'SETTLED', winner = p_winner WHERE id = p_fight_id;

    -- Handle DRAW or CANCELLED - Refund all bets
    IF p_winner IN ('DRAW', 'CANCELLED') THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id LOOP
            UPDATE public.profiles SET coin_balance = coin_balance + winning_bet.amount WHERE id = winning_bet.user_id;
            INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('REFUND', winning_bet.user_id, winning_bet.amount);
        END LOOP;
        RETURN;
    END IF;

    -- Handle RED or WHITE wins
    -- Calculate pools and commission
    SELECT COALESCE(SUM(amount), 0) INTO winner_pool FROM public.bets WHERE fight_id = p_fight_id AND choice::text = p_winner::text;
    SELECT COALESCE(SUM(amount), 0) INTO loser_pool FROM public.bets WHERE fight_id = p_fight_id AND choice::text != p_winner::text;
    total_pool := winner_pool + loser_pool;
    total_commission := loser_pool * fight_commission_rate;

    -- Record commission transaction for the operator
    INSERT INTO public.transactions(type, to_user_id, amount) VALUES ('COMMISSION', auth.uid(), total_commission);

    -- Payout to winners
    IF winner_pool > 0 THEN
        FOR winning_bet IN SELECT * FROM public.bets WHERE fight_id = p_fight_id AND choice::text = p_winner::text LOOP
            DECLARE
                payout_amount numeric;
                player_share numeric;
            BEGIN
                player_share := winning_bet.amount / winner_pool;
                payout_amount := winning_bet.amount + (player_share * (loser_pool - total_commission));
                UPDATE public.profiles SET coin_balance = coin_balance + payout_amount WHERE id = winning_bet.user_id;
                INSERT INTO public.transactions (type, to_user_id, amount) VALUES ('WINNING', winning_bet.user_id, payout_amount);
            END;
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to respond to a coin request
CREATE OR REPLACE FUNCTION public.respond_to_coin_request(p_request_id uuid, p_response text)
RETURNS void AS $$
DECLARE
    request record;
BEGIN
    SELECT * INTO request FROM public.coin_requests WHERE id = p_request_id;
    
    -- Security check: only the recipient can respond
    IF request.to_user_id != auth.uid() THEN
        RAISE EXCEPTION 'Permission denied.';
    END IF;

    IF request.status != 'PENDING' THEN
        RAISE EXCEPTION 'Request has already been handled.';
    END IF;

    IF p_response = 'APPROVED' THEN
        -- Check if approver has enough balance
        IF (SELECT coin_balance FROM public.profiles WHERE id = request.to_user_id) < request.amount THEN
            RAISE EXCEPTION 'Insufficient balance to approve request.';
        END IF;

        -- Perform the transfer
        UPDATE public.profiles SET coin_balance = coin_balance - request.amount WHERE id = request.to_user_id;
        UPDATE public.profiles SET coin_balance = coin_balance + request.amount WHERE id = request.from_user_id;

        -- Record transaction
        INSERT INTO public.transactions (type, from_user_id, to_user_id, amount)
        VALUES ('TRANSFER', request.to_user_id, request.from_user_id, request.amount);

        -- Update request status
        UPDATE public.coin_requests SET status = 'APPROVED' WHERE id = p_request_id;

    ELSIF p_response = 'DECLINED' THEN
        UPDATE public.coin_requests SET status = 'DECLINED' WHERE id = p_request_id;
    ELSE
        RAISE EXCEPTION 'Invalid response.';
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to send a message and optionally coins
CREATE OR REPLACE FUNCTION public.send_message(p_receiver_id uuid, p_text text, p_coin_amount numeric)
RETURNS void AS $$
DECLARE
    sender_id uuid := auth.uid();
BEGIN
    -- Insert the message
    INSERT INTO public.messages(sender_id, receiver_id, text) VALUES (sender_id, p_receiver_id, p_text);

    -- Handle coin transfer
    IF p_coin_amount > 0 THEN
        IF (SELECT coin_balance FROM public.profiles WHERE id = sender_id) < p_coin_amount THEN
            RAISE EXCEPTION 'Insufficient balance to send coins.';
        END IF;
        
        UPDATE public.profiles SET coin_balance = coin_balance - p_coin_amount WHERE id = sender_id;
        UPDATE public.profiles SET coin_balance = coin_balance + p_coin_amount WHERE id = p_receiver_id;
        
        INSERT INTO public.transactions(type, from_user_id, to_user_id, amount)
        VALUES ('TRANSFER', sender_id, p_receiver_id, p_coin_amount);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- =================================================================================================
-- 5. RPC FUNCTIONS FOR DATA FETCHING (to centralize logic and security)
-- =================================================================================================

-- Get player's fight and bet history
CREATE OR REPLACE FUNCTION public.get_player_fight_history(p_user_id uuid)
RETURNS TABLE(id bigint, winner public.fight_winner, commission numeric, bet json, outcome text) AS $$
BEGIN
    RETURN QUERY
    SELECT
        f.id,
        f.winner,
        f.commission,
        (SELECT row_to_json(b) FROM public.bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) as bet,
        CASE
            WHEN f.winner IS NOT NULL AND (SELECT b.choice::text FROM public.bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = f.winner::text THEN 'WIN'
            WHEN f.winner IN ('DRAW', 'CANCELLED') AND (SELECT 1 FROM public.bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'REFUND'
            WHEN (SELECT 1 FROM public.bets b WHERE b.fight_id = f.id AND b.user_id = p_user_id) = 1 THEN 'LOSS'
            ELSE NULL
        END as outcome
    FROM public.fights f
    WHERE f.status = 'SETTLED'
    ORDER BY f.id DESC;
END;
$$ LANGUAGE plpgsql;

-- Get user's transaction history
CREATE OR REPLACE FUNCTION public.get_user_transactions(p_user_id uuid)
RETURNS SETOF public.transactions AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM public.transactions
    WHERE from_user_id = p_user_id OR to_user_id = p_user_id
    ORDER BY transaction_timestamp DESC;
END;
$$ LANGUAGE plpgsql;

-- Get pending requests for a master agent from their agents
CREATE OR REPLACE FUNCTION public.get_agent_requests_for_master(p_master_agent_id uuid)
RETURNS SETOF public.coin_requests AS $$
BEGIN
    RETURN QUERY
    SELECT cr.*
    FROM public.coin_requests cr
    JOIN public.profiles p ON cr.from_user_id = p.id
    WHERE p.master_agent_id = p_master_agent_id AND cr.status = 'PENDING'
    ORDER BY cr.created_at ASC;
END;
$$ LANGUAGE plpgsql;

-- Get chat messages between two users
CREATE OR REPLACE FUNCTION public.get_messages(user1_id uuid, user2_id uuid)
RETURNS SETOF public.messages AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM public.messages
    WHERE (sender_id = user1_id AND receiver_id = user2_id)
       OR (sender_id = user2_id AND receiver_id = user1_id)
    ORDER BY created_at ASC;
END;
$$ LANGUAGE plpgsql;


-- =================================================================================================
-- 6. ROW LEVEL SECURITY (RLS)
-- =================================================================================================

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

ALTER TABLE public.fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view fights" ON public.fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Operators can manage fights" ON public.fights FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR' );

ALTER TABLE public.upcoming_fights ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view upcoming fights" ON public.upcoming_fights FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Operators can manage upcoming fights" ON public.upcoming_fights FOR ALL USING ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'OPERATOR' );

ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "All users can view all bets" ON public.bets FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Players can place their own bets" ON public.bets FOR INSERT WITH CHECK (auth.uid() = user_id AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'PLAYER');

ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own transactions" ON public.transactions FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

ALTER TABLE public.coin_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view requests they are involved in" ON public.coin_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can create their own requests" ON public.coin_requests FOR INSERT WITH CHECK (auth.uid() = from_user_id);

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view messages they sent or received" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- =================================================================================================
-- 7. REAL-TIME CONFIGURATION
-- =================================================================================================

-- Set REPLICA IDENTITY to FULL for tables that will be part of the publication.
-- This is necessary for real-time to broadcast changes correctly, especially with RLS enabled.
ALTER TABLE public.profiles REPLICA IDENTITY FULL;
ALTER TABLE public.fights REPLICA IDENTITY FULL;
ALTER TABLE public.upcoming_fights REPLICA IDENTITY FULL;
ALTER TABLE public.bets REPLICA IDENTITY FULL;
ALTER TABLE public.transactions REPLICA IDENTITY FULL;
ALTER TABLE public.coin_requests REPLICA IDENTITY FULL;
ALTER TABLE public.messages REPLICA IDENTITY FULL;

-- Add tables to the publication for real-time updates
DROP PUBLICATION IF EXISTS supabase_realtime;
CREATE PUBLICATION supabase_realtime FOR ALL TABLES;


-- =================================================================================================
-- END OF SCRIPT
-- =================================================================================================